// Code generated by Prisma (prisma@1.18.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  exception: (where?: ExceptionWhereInput) => Promise<boolean>;
  exceptionAuthorization: (
    where?: ExceptionAuthorizationWhereInput
  ) => Promise<boolean>;
  exceptionSlot: (where?: ExceptionSlotWhereInput) => Promise<boolean>;
  schedule: (where?: ScheduleWhereInput) => Promise<boolean>;
  scheduleOfflineElement: (
    where?: ScheduleOfflineElementWhereInput
  ) => Promise<boolean>;
  scheduleRestlineElement: (
    where?: ScheduleRestlineElementWhereInput
  ) => Promise<boolean>;
  scheduleTimelineElement: (
    where?: ScheduleTimelineElementWhereInput
  ) => Promise<boolean>;
  shift: (where?: ShiftWhereInput) => Promise<boolean>;
  shiftSlot: (where?: ShiftSlotWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  department: (where: DepartmentWhereUniqueInput) => Department;
  departments: (
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DepartmentNode>;
  departmentsConnection: (
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DepartmentConnection;
  employee: (where: EmployeeWhereUniqueInput) => Employee;
  employees: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<EmployeeNode>;
  employeesConnection: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EmployeeConnection;
  exception: (where: ExceptionWhereUniqueInput) => Exception;
  exceptions: (
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionNode>;
  exceptionsConnection: (
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionConnection;
  exceptionAuthorization: (
    where: ExceptionAuthorizationWhereUniqueInput
  ) => ExceptionAuthorization;
  exceptionAuthorizations: (
    args?: {
      where?: ExceptionAuthorizationWhereInput;
      orderBy?: ExceptionAuthorizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionAuthorizationNode>;
  exceptionAuthorizationsConnection: (
    args?: {
      where?: ExceptionAuthorizationWhereInput;
      orderBy?: ExceptionAuthorizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionAuthorizationConnection;
  exceptionSlot: (where: ExceptionSlotWhereUniqueInput) => ExceptionSlot;
  exceptionSlots: (
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionSlotNode>;
  exceptionSlotsConnection: (
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionSlotConnection;
  schedule: (where: ScheduleWhereUniqueInput) => Schedule;
  schedules: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleNode>;
  schedulesConnection: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleConnection;
  scheduleOfflineElement: (
    where: ScheduleOfflineElementWhereUniqueInput
  ) => ScheduleOfflineElement;
  scheduleOfflineElements: (
    args?: {
      where?: ScheduleOfflineElementWhereInput;
      orderBy?: ScheduleOfflineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleOfflineElementNode>;
  scheduleOfflineElementsConnection: (
    args?: {
      where?: ScheduleOfflineElementWhereInput;
      orderBy?: ScheduleOfflineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleOfflineElementConnection;
  scheduleRestlineElement: (
    where: ScheduleRestlineElementWhereUniqueInput
  ) => ScheduleRestlineElement;
  scheduleRestlineElements: (
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleRestlineElementNode>;
  scheduleRestlineElementsConnection: (
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleRestlineElementConnection;
  scheduleTimelineElement: (
    where: ScheduleTimelineElementWhereUniqueInput
  ) => ScheduleTimelineElement;
  scheduleTimelineElements: (
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleTimelineElementNode>;
  scheduleTimelineElementsConnection: (
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleTimelineElementConnection;
  shift: (where: ShiftWhereUniqueInput) => Shift;
  shifts: (
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ShiftNode>;
  shiftsConnection: (
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShiftConnection;
  shiftSlot: (where: ShiftSlotWhereUniqueInput) => ShiftSlot;
  shiftSlots: (
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ShiftSlotNode>;
  shiftSlotsConnection: (
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShiftSlotConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserNode>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createDepartment: (data: DepartmentCreateInput) => Department;
  updateDepartment: (
    args: { data: DepartmentUpdateInput; where: DepartmentWhereUniqueInput }
  ) => Department;
  updateManyDepartments: (
    args: { data: DepartmentUpdateInput; where?: DepartmentWhereInput }
  ) => BatchPayload;
  upsertDepartment: (
    args: {
      where: DepartmentWhereUniqueInput;
      create: DepartmentCreateInput;
      update: DepartmentUpdateInput;
    }
  ) => Department;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => Department;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayload;
  createEmployee: (data: EmployeeCreateInput) => Employee;
  updateEmployee: (
    args: { data: EmployeeUpdateInput; where: EmployeeWhereUniqueInput }
  ) => Employee;
  updateManyEmployees: (
    args: { data: EmployeeUpdateInput; where?: EmployeeWhereInput }
  ) => BatchPayload;
  upsertEmployee: (
    args: {
      where: EmployeeWhereUniqueInput;
      create: EmployeeCreateInput;
      update: EmployeeUpdateInput;
    }
  ) => Employee;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => Employee;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayload;
  createException: (data: ExceptionCreateInput) => Exception;
  updateException: (
    args: { data: ExceptionUpdateInput; where: ExceptionWhereUniqueInput }
  ) => Exception;
  updateManyExceptions: (
    args: { data: ExceptionUpdateInput; where?: ExceptionWhereInput }
  ) => BatchPayload;
  upsertException: (
    args: {
      where: ExceptionWhereUniqueInput;
      create: ExceptionCreateInput;
      update: ExceptionUpdateInput;
    }
  ) => Exception;
  deleteException: (where: ExceptionWhereUniqueInput) => Exception;
  deleteManyExceptions: (where?: ExceptionWhereInput) => BatchPayload;
  createExceptionAuthorization: (
    data: ExceptionAuthorizationCreateInput
  ) => ExceptionAuthorization;
  updateExceptionAuthorization: (
    args: {
      data: ExceptionAuthorizationUpdateInput;
      where: ExceptionAuthorizationWhereUniqueInput;
    }
  ) => ExceptionAuthorization;
  updateManyExceptionAuthorizations: (
    args: {
      data: ExceptionAuthorizationUpdateInput;
      where?: ExceptionAuthorizationWhereInput;
    }
  ) => BatchPayload;
  upsertExceptionAuthorization: (
    args: {
      where: ExceptionAuthorizationWhereUniqueInput;
      create: ExceptionAuthorizationCreateInput;
      update: ExceptionAuthorizationUpdateInput;
    }
  ) => ExceptionAuthorization;
  deleteExceptionAuthorization: (
    where: ExceptionAuthorizationWhereUniqueInput
  ) => ExceptionAuthorization;
  deleteManyExceptionAuthorizations: (
    where?: ExceptionAuthorizationWhereInput
  ) => BatchPayload;
  createExceptionSlot: (data: ExceptionSlotCreateInput) => ExceptionSlot;
  updateExceptionSlot: (
    args: {
      data: ExceptionSlotUpdateInput;
      where: ExceptionSlotWhereUniqueInput;
    }
  ) => ExceptionSlot;
  updateManyExceptionSlots: (
    args: { data: ExceptionSlotUpdateInput; where?: ExceptionSlotWhereInput }
  ) => BatchPayload;
  upsertExceptionSlot: (
    args: {
      where: ExceptionSlotWhereUniqueInput;
      create: ExceptionSlotCreateInput;
      update: ExceptionSlotUpdateInput;
    }
  ) => ExceptionSlot;
  deleteExceptionSlot: (where: ExceptionSlotWhereUniqueInput) => ExceptionSlot;
  deleteManyExceptionSlots: (where?: ExceptionSlotWhereInput) => BatchPayload;
  createSchedule: (data: ScheduleCreateInput) => Schedule;
  updateSchedule: (
    args: { data: ScheduleUpdateInput; where: ScheduleWhereUniqueInput }
  ) => Schedule;
  updateManySchedules: (
    args: { data: ScheduleUpdateInput; where?: ScheduleWhereInput }
  ) => BatchPayload;
  upsertSchedule: (
    args: {
      where: ScheduleWhereUniqueInput;
      create: ScheduleCreateInput;
      update: ScheduleUpdateInput;
    }
  ) => Schedule;
  deleteSchedule: (where: ScheduleWhereUniqueInput) => Schedule;
  deleteManySchedules: (where?: ScheduleWhereInput) => BatchPayload;
  createScheduleOfflineElement: (
    data: ScheduleOfflineElementCreateInput
  ) => ScheduleOfflineElement;
  updateScheduleOfflineElement: (
    args: {
      data: ScheduleOfflineElementUpdateInput;
      where: ScheduleOfflineElementWhereUniqueInput;
    }
  ) => ScheduleOfflineElement;
  updateManyScheduleOfflineElements: (
    args: {
      data: ScheduleOfflineElementUpdateInput;
      where?: ScheduleOfflineElementWhereInput;
    }
  ) => BatchPayload;
  upsertScheduleOfflineElement: (
    args: {
      where: ScheduleOfflineElementWhereUniqueInput;
      create: ScheduleOfflineElementCreateInput;
      update: ScheduleOfflineElementUpdateInput;
    }
  ) => ScheduleOfflineElement;
  deleteScheduleOfflineElement: (
    where: ScheduleOfflineElementWhereUniqueInput
  ) => ScheduleOfflineElement;
  deleteManyScheduleOfflineElements: (
    where?: ScheduleOfflineElementWhereInput
  ) => BatchPayload;
  createScheduleRestlineElement: (
    data: ScheduleRestlineElementCreateInput
  ) => ScheduleRestlineElement;
  updateScheduleRestlineElement: (
    args: {
      data: ScheduleRestlineElementUpdateInput;
      where: ScheduleRestlineElementWhereUniqueInput;
    }
  ) => ScheduleRestlineElement;
  updateManyScheduleRestlineElements: (
    args: {
      data: ScheduleRestlineElementUpdateInput;
      where?: ScheduleRestlineElementWhereInput;
    }
  ) => BatchPayload;
  upsertScheduleRestlineElement: (
    args: {
      where: ScheduleRestlineElementWhereUniqueInput;
      create: ScheduleRestlineElementCreateInput;
      update: ScheduleRestlineElementUpdateInput;
    }
  ) => ScheduleRestlineElement;
  deleteScheduleRestlineElement: (
    where: ScheduleRestlineElementWhereUniqueInput
  ) => ScheduleRestlineElement;
  deleteManyScheduleRestlineElements: (
    where?: ScheduleRestlineElementWhereInput
  ) => BatchPayload;
  createScheduleTimelineElement: (
    data: ScheduleTimelineElementCreateInput
  ) => ScheduleTimelineElement;
  updateScheduleTimelineElement: (
    args: {
      data: ScheduleTimelineElementUpdateInput;
      where: ScheduleTimelineElementWhereUniqueInput;
    }
  ) => ScheduleTimelineElement;
  updateManyScheduleTimelineElements: (
    args: {
      data: ScheduleTimelineElementUpdateInput;
      where?: ScheduleTimelineElementWhereInput;
    }
  ) => BatchPayload;
  upsertScheduleTimelineElement: (
    args: {
      where: ScheduleTimelineElementWhereUniqueInput;
      create: ScheduleTimelineElementCreateInput;
      update: ScheduleTimelineElementUpdateInput;
    }
  ) => ScheduleTimelineElement;
  deleteScheduleTimelineElement: (
    where: ScheduleTimelineElementWhereUniqueInput
  ) => ScheduleTimelineElement;
  deleteManyScheduleTimelineElements: (
    where?: ScheduleTimelineElementWhereInput
  ) => BatchPayload;
  createShift: (data: ShiftCreateInput) => Shift;
  updateShift: (
    args: { data: ShiftUpdateInput; where: ShiftWhereUniqueInput }
  ) => Shift;
  updateManyShifts: (
    args: { data: ShiftUpdateInput; where?: ShiftWhereInput }
  ) => BatchPayload;
  upsertShift: (
    args: {
      where: ShiftWhereUniqueInput;
      create: ShiftCreateInput;
      update: ShiftUpdateInput;
    }
  ) => Shift;
  deleteShift: (where: ShiftWhereUniqueInput) => Shift;
  deleteManyShifts: (where?: ShiftWhereInput) => BatchPayload;
  createShiftSlot: (data: ShiftSlotCreateInput) => ShiftSlot;
  updateShiftSlot: (
    args: { data: ShiftSlotUpdateInput; where: ShiftSlotWhereUniqueInput }
  ) => ShiftSlot;
  updateManyShiftSlots: (
    args: { data: ShiftSlotUpdateInput; where?: ShiftSlotWhereInput }
  ) => BatchPayload;
  upsertShiftSlot: (
    args: {
      where: ShiftSlotWhereUniqueInput;
      create: ShiftSlotCreateInput;
      update: ShiftSlotUpdateInput;
    }
  ) => ShiftSlot;
  deleteShiftSlot: (where: ShiftSlotWhereUniqueInput) => ShiftSlot;
  deleteManyShiftSlots: (where?: ShiftSlotWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  exception: (
    where?: ExceptionSubscriptionWhereInput
  ) => ExceptionSubscriptionPayloadSubscription;
  exceptionAuthorization: (
    where?: ExceptionAuthorizationSubscriptionWhereInput
  ) => ExceptionAuthorizationSubscriptionPayloadSubscription;
  exceptionSlot: (
    where?: ExceptionSlotSubscriptionWhereInput
  ) => ExceptionSlotSubscriptionPayloadSubscription;
  schedule: (
    where?: ScheduleSubscriptionWhereInput
  ) => ScheduleSubscriptionPayloadSubscription;
  scheduleOfflineElement: (
    where?: ScheduleOfflineElementSubscriptionWhereInput
  ) => ScheduleOfflineElementSubscriptionPayloadSubscription;
  scheduleRestlineElement: (
    where?: ScheduleRestlineElementSubscriptionWhereInput
  ) => ScheduleRestlineElementSubscriptionPayloadSubscription;
  scheduleTimelineElement: (
    where?: ScheduleTimelineElementSubscriptionWhereInput
  ) => ScheduleTimelineElementSubscriptionPayloadSubscription;
  shift: (
    where?: ShiftSubscriptionWhereInput
  ) => ShiftSubscriptionPayloadSubscription;
  shiftSlot: (
    where?: ShiftSlotSubscriptionWhereInput
  ) => ShiftSlotSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleOfflineCategory =
  | "SCH_DAY_OFF"
  | "SCH_DAY_VACATION"
  | "SCH_DAY_HOLIDAY"
  | "SCH_DAY_SICK"
  | "SCH_DAY_PAID"
  | "SCH_DAY_UNPAID";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleOfflineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleRestlineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "startRequireEvent_ASC"
  | "startRequireEvent_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "endRequireEvent_ASC"
  | "endRequireEvent_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExceptionAuthorizationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "granted_ASC"
  | "granted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleTimelineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "startRequireEvent_ASC"
  | "startRequireEvent_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "endRequireEvent_ASC"
  | "endRequireEvent_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SexEnum = "M" | "F";

export type ShiftSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "index_ASC"
  | "index_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExceptionSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleRestlineCategory = "SCH_REST_LUNCH";

export type EmployeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "nameFirst_ASC"
  | "nameFirst_DESC"
  | "nameMiddle_ASC"
  | "nameMiddle_DESC"
  | "namePaternal_ASC"
  | "namePaternal_DESC"
  | "nameMaternal_ASC"
  | "nameMaternal_DESC"
  | "documentType_ASC"
  | "documentType_DESC"
  | "documentNumber_ASC"
  | "documentNumber_DESC"
  | "sex_ASC"
  | "sex_DESC"
  | "dateOfBirth_ASC"
  | "dateOfBirth_DESC"
  | "nationality_ASC"
  | "nationality_DESC"
  | "jubilado_ASC"
  | "jubilado_DESC"
  | "personaConDiscapacidad_ASC"
  | "personaConDiscapacidad_DESC"
  | "tutorPersonaConDiscapacidad_ASC"
  | "tutorPersonaConDiscapacidad_DESC"
  | "cajaDeSalud_ASC"
  | "cajaDeSalud_DESC"
  | "aportaAFP_ASC"
  | "aportaAFP_DESC"
  | "AFP_ASC"
  | "AFP_DESC"
  | "cargo_ASC"
  | "cargo_DESC"
  | "zkTimePin_ASC"
  | "zkTimePin_DESC";

export type ScheduleTimelineCategory =
  | "SCH_TIME_WORK"
  | "SCH_TIME_EXTRA"
  | "SCH_TIME_MATERNAL"
  | "SCH_TIME_LEAVE";

export type ShiftOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "startIndex_ASC"
  | "startIndex_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ExceptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DocumentTypeEnum = "CI" | "PASSAPORTE";

export type ScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "baseTime_ASC"
  | "baseTime_DESC"
  | "custom_ASC"
  | "custom_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface UserCreateInput {
  username: String;
  password: String;
  departments?: EmployeeCreateManyInput;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ShiftUpdateManyWithoutEmployeeInput {
  create?: ShiftCreateWithoutEmployeeInput[] | ShiftCreateWithoutEmployeeInput;
  delete?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  connect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  disconnect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  update?:
    | ShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ShiftUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ShiftUpsertWithWhereUniqueWithoutEmployeeInput;
}

export interface ScheduleOfflineElementWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  category?: ScheduleOfflineCategory;
  category_not?: ScheduleOfflineCategory;
  category_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  category_not_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  AND?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
  OR?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
  NOT?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserUpdateDataInput {
  username?: String;
  password?: String;
  departments?: EmployeeUpdateManyInput;
}

export interface EmployeeUpsertWithWhereUniqueNestedInput {
  where: EmployeeWhereUniqueInput;
  update: EmployeeUpdateDataInput;
  create: EmployeeCreateInput;
}

export interface ShiftUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ShiftWhereUniqueInput;
  data: ShiftUpdateWithoutEmployeeDataInput;
}

export interface DepartmentUpsertWithoutSubordinatesInput {
  update: DepartmentUpdateWithoutSubordinatesDataInput;
  create: DepartmentCreateWithoutSubordinatesInput;
}

export interface ShiftSlotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShiftSlotWhereInput;
  AND?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
  OR?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
  NOT?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
}

export type ShiftSlotWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ScheduleTimelineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleTimelineElementWhereInput;
  AND?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
  OR?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface ScheduleRestlineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleRestlineElementWhereInput;
  AND?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
  OR?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface ScheduleOfflineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleOfflineElementWhereInput;
  AND?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
  OR?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ExceptionSlotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionSlotWhereInput;
  AND?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
  OR?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
  NOT?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: UUID;
  username?: String;
}>;

export interface UserWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  departments_every?: EmployeeWhereInput;
  departments_some?: EmployeeWhereInput;
  departments_none?: EmployeeWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface DepartmentUpdateWithoutSubordinatesDataInput {
  name?: String;
  supervisors?: UserUpdateManyInput;
}

export interface ExceptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionWhereInput;
  AND?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
  OR?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
  NOT?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
}

export interface DepartmentUpdateOneWithoutSubordinatesInput {
  create?: DepartmentCreateWithoutSubordinatesInput;
  update?: DepartmentUpdateWithoutSubordinatesDataInput;
  upsert?: DepartmentUpsertWithoutSubordinatesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DepartmentWhereUniqueInput;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DepartmentWhereInput;
  AND?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  OR?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  NOT?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
}

export interface EmployeeUpdateDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  departments?: EmployeeUpdateManyInput;
}

export interface EmployeeUpdateWithWhereUniqueNestedInput {
  where: EmployeeWhereUniqueInput;
  data: EmployeeUpdateDataInput;
}

export interface EmployeeUpsertWithoutShiftsInput {
  update: EmployeeUpdateWithoutShiftsDataInput;
  create: EmployeeCreateWithoutShiftsInput;
}

export interface EmployeeUpdateWithoutShiftsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
}

export interface DepartmentWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  subordinates_every?: EmployeeWhereInput;
  subordinates_some?: EmployeeWhereInput;
  subordinates_none?: EmployeeWhereInput;
  supervisors_every?: UserWhereInput;
  supervisors_some?: UserWhereInput;
  supervisors_none?: UserWhereInput;
  AND?: DepartmentWhereInput[] | DepartmentWhereInput;
  OR?: DepartmentWhereInput[] | DepartmentWhereInput;
  NOT?: DepartmentWhereInput[] | DepartmentWhereInput;
}

export interface DepartmentCreateInput {
  name: String;
  subordinates?: EmployeeCreateManyWithoutDepartmentInput;
  supervisors?: UserCreateManyInput;
}

export interface ExceptionWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  employee?: EmployeeWhereInput;
  slots_every?: ExceptionSlotWhereInput;
  slots_some?: ExceptionSlotWhereInput;
  slots_none?: ExceptionSlotWhereInput;
  owner?: UserWhereInput;
  AND?: ExceptionWhereInput[] | ExceptionWhereInput;
  OR?: ExceptionWhereInput[] | ExceptionWhereInput;
  NOT?: ExceptionWhereInput[] | ExceptionWhereInput;
}

export interface EmployeeCreateManyWithoutDepartmentInput {
  create?:
    | EmployeeCreateWithoutDepartmentInput[]
    | EmployeeCreateWithoutDepartmentInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
}

export interface EmployeeCreateWithoutShiftsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
}

export interface EmployeeCreateWithoutDepartmentInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin: Int;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
}

export interface ShiftCreateInput {
  description?: String;
  employee: EmployeeCreateOneWithoutShiftsInput;
  startDate: DateTimeInput;
  endDate?: DateTimeInput;
  startIndex: Int;
  slots?: ShiftSlotCreateManyInput;
  owner: UserCreateOneInput;
}

export interface ShiftCreateManyWithoutEmployeeInput {
  create?: ShiftCreateWithoutEmployeeInput[] | ShiftCreateWithoutEmployeeInput;
  connect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
}

export interface ScheduleTimelineElementUpdateInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  startRequireEvent?: Boolean;
  endTime?: Int;
  endRequireEvent?: Boolean;
}

export interface ShiftCreateWithoutEmployeeInput {
  description?: String;
  startDate: DateTimeInput;
  endDate?: DateTimeInput;
  startIndex: Int;
  slots?: ShiftSlotCreateManyInput;
  owner: UserCreateOneInput;
}

export interface ScheduleRestlineElementUpdateInput {
  category?: ScheduleRestlineCategory;
  startTime?: Int;
  startRequireEvent?: Boolean;
  endTime?: Int;
  endRequireEvent?: Boolean;
  duration?: Int;
}

export interface ShiftSlotCreateManyInput {
  create?: ShiftSlotCreateInput[] | ShiftSlotCreateInput;
  connect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
}

export interface ScheduleUpdateInput {
  description?: String;
  baseTime?: Int;
  custom?: Boolean;
  timeline?: ScheduleTimelineElementUpdateManyInput;
  restline?: ScheduleRestlineElementUpdateManyInput;
  offline1?: ScheduleOfflineElementUpdateOneInput;
  offline2?: ScheduleOfflineElementUpdateOneInput;
}

export interface ShiftSlotCreateInput {
  schedule: ScheduleCreateOneInput;
  index: Int;
}

export type ExceptionSlotWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ScheduleCreateOneInput {
  create?: ScheduleCreateInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ExceptionAuthorizationCreateInput {
  granted: Boolean;
  user: UserCreateOneInput;
}

export interface ScheduleCreateInput {
  description?: String;
  baseTime: Int;
  custom?: Boolean;
  timeline?: ScheduleTimelineElementCreateManyInput;
  restline?: ScheduleRestlineElementCreateManyInput;
  offline1?: ScheduleOfflineElementCreateOneInput;
  offline2?: ScheduleOfflineElementCreateOneInput;
}

export type ScheduleWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ScheduleTimelineElementCreateManyInput {
  create?:
    | ScheduleTimelineElementCreateInput[]
    | ScheduleTimelineElementCreateInput;
  connect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
}

export interface ExceptionSlotUpdateDataInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  date?: DateTimeInput;
}

export interface ScheduleTimelineElementCreateInput {
  category: ScheduleTimelineCategory;
  startTime: Int;
  startRequireEvent: Boolean;
  endTime: Int;
  endRequireEvent: Boolean;
}

export interface ExceptionSlotUpdateManyInput {
  create?: ExceptionSlotCreateInput[] | ExceptionSlotCreateInput;
  update?:
    | ExceptionSlotUpdateWithWhereUniqueNestedInput[]
    | ExceptionSlotUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ExceptionSlotUpsertWithWhereUniqueNestedInput[]
    | ExceptionSlotUpsertWithWhereUniqueNestedInput;
  delete?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
  connect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
  disconnect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
}

export interface ScheduleRestlineElementCreateManyInput {
  create?:
    | ScheduleRestlineElementCreateInput[]
    | ScheduleRestlineElementCreateInput;
  connect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
}

export interface EmployeeUpsertNestedInput {
  update: EmployeeUpdateDataInput;
  create: EmployeeCreateInput;
}

export interface ScheduleRestlineElementCreateInput {
  category: ScheduleRestlineCategory;
  startTime: Int;
  startRequireEvent: Boolean;
  endTime: Int;
  endRequireEvent: Boolean;
  duration: Int;
}

export interface ExceptionUpdateInput {
  employee?: EmployeeUpdateOneRequiredInput;
  slots?: ExceptionSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface ScheduleOfflineElementCreateOneInput {
  create?: ScheduleOfflineElementCreateInput;
  connect?: ScheduleOfflineElementWhereUniqueInput;
}

export type ScheduleRestlineElementWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ScheduleOfflineElementCreateInput {
  category: ScheduleOfflineCategory;
}

export interface EmployeeCreateOneInput {
  create?: EmployeeCreateInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export type ScheduleTimelineElementWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface EmployeeUpdateManyInput {
  create?: EmployeeCreateInput[] | EmployeeCreateInput;
  update?:
    | EmployeeUpdateWithWhereUniqueNestedInput[]
    | EmployeeUpdateWithWhereUniqueNestedInput;
  upsert?:
    | EmployeeUpsertWithWhereUniqueNestedInput[]
    | EmployeeUpsertWithWhereUniqueNestedInput;
  delete?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  disconnect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
}

export interface EmployeeUpsertWithWhereUniqueWithoutDepartmentInput {
  where: EmployeeWhereUniqueInput;
  update: EmployeeUpdateWithoutDepartmentDataInput;
  create: EmployeeCreateWithoutDepartmentInput;
}

export interface EmployeeCreateManyInput {
  create?: EmployeeCreateInput[] | EmployeeCreateInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
}

export type ShiftWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface EmployeeCreateInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
}

export interface ShiftSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShiftWhereInput;
  AND?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
  OR?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
  NOT?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
}

export interface DepartmentCreateOneWithoutSubordinatesInput {
  create?: DepartmentCreateWithoutSubordinatesInput;
  connect?: DepartmentWhereUniqueInput;
}

export interface ShiftSlotWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  schedule?: ScheduleWhereInput;
  index?: Int;
  index_not?: Int;
  index_in?: Int[] | Int;
  index_not_in?: Int[] | Int;
  index_lt?: Int;
  index_lte?: Int;
  index_gt?: Int;
  index_gte?: Int;
  AND?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
  OR?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
  NOT?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
}

export interface DepartmentCreateWithoutSubordinatesInput {
  name: String;
  supervisors?: UserCreateManyInput;
}

export interface ShiftWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  employee?: EmployeeWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  startIndex?: Int;
  startIndex_not?: Int;
  startIndex_in?: Int[] | Int;
  startIndex_not_in?: Int[] | Int;
  startIndex_lt?: Int;
  startIndex_lte?: Int;
  startIndex_gt?: Int;
  startIndex_gte?: Int;
  slots_every?: ShiftSlotWhereInput;
  slots_some?: ShiftSlotWhereInput;
  slots_none?: ShiftSlotWhereInput;
  owner?: UserWhereInput;
  AND?: ShiftWhereInput[] | ShiftWhereInput;
  OR?: ShiftWhereInput[] | ShiftWhereInput;
  NOT?: ShiftWhereInput[] | ShiftWhereInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EmployeeWhereInput;
  AND?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  OR?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  NOT?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
}

export interface DepartmentUpdateInput {
  name?: String;
  subordinates?: EmployeeUpdateManyWithoutDepartmentInput;
  supervisors?: UserUpdateManyInput;
}

export interface ShiftSlotUpdateInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  index?: Int;
}

export interface EmployeeUpdateManyWithoutDepartmentInput {
  create?:
    | EmployeeCreateWithoutDepartmentInput[]
    | EmployeeCreateWithoutDepartmentInput;
  delete?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  disconnect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  update?:
    | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput;
  upsert?:
    | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput;
}

export interface ExceptionSlotWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  schedule?: ScheduleWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
  OR?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
  NOT?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
}

export interface EmployeeUpdateWithWhereUniqueWithoutDepartmentInput {
  where: EmployeeWhereUniqueInput;
  data: EmployeeUpdateWithoutDepartmentDataInput;
}

export interface ShiftUpdateInput {
  description?: String;
  employee?: EmployeeUpdateOneRequiredWithoutShiftsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  startIndex?: Int;
  slots?: ShiftSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface EmployeeUpdateWithoutDepartmentDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin?: Int;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
}

export type ExceptionAuthorizationWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ScheduleRestlineElementWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  category?: ScheduleRestlineCategory;
  category_not?: ScheduleRestlineCategory;
  category_in?: ScheduleRestlineCategory[] | ScheduleRestlineCategory;
  category_not_in?: ScheduleRestlineCategory[] | ScheduleRestlineCategory;
  startTime?: Int;
  startTime_not?: Int;
  startTime_in?: Int[] | Int;
  startTime_not_in?: Int[] | Int;
  startTime_lt?: Int;
  startTime_lte?: Int;
  startTime_gt?: Int;
  startTime_gte?: Int;
  startRequireEvent?: Boolean;
  startRequireEvent_not?: Boolean;
  endTime?: Int;
  endTime_not?: Int;
  endTime_in?: Int[] | Int;
  endTime_not_in?: Int[] | Int;
  endTime_lt?: Int;
  endTime_lte?: Int;
  endTime_gt?: Int;
  endTime_gte?: Int;
  endRequireEvent?: Boolean;
  endRequireEvent_not?: Boolean;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  AND?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
  OR?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
  NOT?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
}

export interface ScheduleOfflineElementUpdateInput {
  category?: ScheduleOfflineCategory;
}

export interface ScheduleTimelineElementWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  category?: ScheduleTimelineCategory;
  category_not?: ScheduleTimelineCategory;
  category_in?: ScheduleTimelineCategory[] | ScheduleTimelineCategory;
  category_not_in?: ScheduleTimelineCategory[] | ScheduleTimelineCategory;
  startTime?: Int;
  startTime_not?: Int;
  startTime_in?: Int[] | Int;
  startTime_not_in?: Int[] | Int;
  startTime_lt?: Int;
  startTime_lte?: Int;
  startTime_gt?: Int;
  startTime_gte?: Int;
  startRequireEvent?: Boolean;
  startRequireEvent_not?: Boolean;
  endTime?: Int;
  endTime_not?: Int;
  endTime_in?: Int[] | Int;
  endTime_not_in?: Int[] | Int;
  endTime_lt?: Int;
  endTime_lte?: Int;
  endTime_gt?: Int;
  endTime_gte?: Int;
  endRequireEvent?: Boolean;
  endRequireEvent_not?: Boolean;
  AND?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
  OR?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
  NOT?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
}

export interface ExceptionAuthorizationUpdateInput {
  granted?: Boolean;
  user?: UserUpdateOneRequiredInput;
}

export interface ShiftUpdateWithoutEmployeeDataInput {
  description?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  startIndex?: Int;
  slots?: ShiftSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface EmployeeWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  nameFirst?: String;
  nameFirst_not?: String;
  nameFirst_in?: String[] | String;
  nameFirst_not_in?: String[] | String;
  nameFirst_lt?: String;
  nameFirst_lte?: String;
  nameFirst_gt?: String;
  nameFirst_gte?: String;
  nameFirst_contains?: String;
  nameFirst_not_contains?: String;
  nameFirst_starts_with?: String;
  nameFirst_not_starts_with?: String;
  nameFirst_ends_with?: String;
  nameFirst_not_ends_with?: String;
  nameMiddle?: String;
  nameMiddle_not?: String;
  nameMiddle_in?: String[] | String;
  nameMiddle_not_in?: String[] | String;
  nameMiddle_lt?: String;
  nameMiddle_lte?: String;
  nameMiddle_gt?: String;
  nameMiddle_gte?: String;
  nameMiddle_contains?: String;
  nameMiddle_not_contains?: String;
  nameMiddle_starts_with?: String;
  nameMiddle_not_starts_with?: String;
  nameMiddle_ends_with?: String;
  nameMiddle_not_ends_with?: String;
  namePaternal?: String;
  namePaternal_not?: String;
  namePaternal_in?: String[] | String;
  namePaternal_not_in?: String[] | String;
  namePaternal_lt?: String;
  namePaternal_lte?: String;
  namePaternal_gt?: String;
  namePaternal_gte?: String;
  namePaternal_contains?: String;
  namePaternal_not_contains?: String;
  namePaternal_starts_with?: String;
  namePaternal_not_starts_with?: String;
  namePaternal_ends_with?: String;
  namePaternal_not_ends_with?: String;
  nameMaternal?: String;
  nameMaternal_not?: String;
  nameMaternal_in?: String[] | String;
  nameMaternal_not_in?: String[] | String;
  nameMaternal_lt?: String;
  nameMaternal_lte?: String;
  nameMaternal_gt?: String;
  nameMaternal_gte?: String;
  nameMaternal_contains?: String;
  nameMaternal_not_contains?: String;
  nameMaternal_starts_with?: String;
  nameMaternal_not_starts_with?: String;
  nameMaternal_ends_with?: String;
  nameMaternal_not_ends_with?: String;
  documentType?: DocumentTypeEnum;
  documentType_not?: DocumentTypeEnum;
  documentType_in?: DocumentTypeEnum[] | DocumentTypeEnum;
  documentType_not_in?: DocumentTypeEnum[] | DocumentTypeEnum;
  documentNumber?: String;
  documentNumber_not?: String;
  documentNumber_in?: String[] | String;
  documentNumber_not_in?: String[] | String;
  documentNumber_lt?: String;
  documentNumber_lte?: String;
  documentNumber_gt?: String;
  documentNumber_gte?: String;
  documentNumber_contains?: String;
  documentNumber_not_contains?: String;
  documentNumber_starts_with?: String;
  documentNumber_not_starts_with?: String;
  documentNumber_ends_with?: String;
  documentNumber_not_ends_with?: String;
  sex?: SexEnum;
  sex_not?: SexEnum;
  sex_in?: SexEnum[] | SexEnum;
  sex_not_in?: SexEnum[] | SexEnum;
  dateOfBirth?: DateTimeInput;
  dateOfBirth_not?: DateTimeInput;
  dateOfBirth_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_not_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_lt?: DateTimeInput;
  dateOfBirth_lte?: DateTimeInput;
  dateOfBirth_gt?: DateTimeInput;
  dateOfBirth_gte?: DateTimeInput;
  nationality?: String;
  nationality_not?: String;
  nationality_in?: String[] | String;
  nationality_not_in?: String[] | String;
  nationality_lt?: String;
  nationality_lte?: String;
  nationality_gt?: String;
  nationality_gte?: String;
  nationality_contains?: String;
  nationality_not_contains?: String;
  nationality_starts_with?: String;
  nationality_not_starts_with?: String;
  nationality_ends_with?: String;
  nationality_not_ends_with?: String;
  jubilado?: Int;
  jubilado_not?: Int;
  jubilado_in?: Int[] | Int;
  jubilado_not_in?: Int[] | Int;
  jubilado_lt?: Int;
  jubilado_lte?: Int;
  jubilado_gt?: Int;
  jubilado_gte?: Int;
  personaConDiscapacidad?: Int;
  personaConDiscapacidad_not?: Int;
  personaConDiscapacidad_in?: Int[] | Int;
  personaConDiscapacidad_not_in?: Int[] | Int;
  personaConDiscapacidad_lt?: Int;
  personaConDiscapacidad_lte?: Int;
  personaConDiscapacidad_gt?: Int;
  personaConDiscapacidad_gte?: Int;
  tutorPersonaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad_not?: Int;
  tutorPersonaConDiscapacidad_in?: Int[] | Int;
  tutorPersonaConDiscapacidad_not_in?: Int[] | Int;
  tutorPersonaConDiscapacidad_lt?: Int;
  tutorPersonaConDiscapacidad_lte?: Int;
  tutorPersonaConDiscapacidad_gt?: Int;
  tutorPersonaConDiscapacidad_gte?: Int;
  cajaDeSalud?: Int;
  cajaDeSalud_not?: Int;
  cajaDeSalud_in?: Int[] | Int;
  cajaDeSalud_not_in?: Int[] | Int;
  cajaDeSalud_lt?: Int;
  cajaDeSalud_lte?: Int;
  cajaDeSalud_gt?: Int;
  cajaDeSalud_gte?: Int;
  aportaAFP?: Int;
  aportaAFP_not?: Int;
  aportaAFP_in?: Int[] | Int;
  aportaAFP_not_in?: Int[] | Int;
  aportaAFP_lt?: Int;
  aportaAFP_lte?: Int;
  aportaAFP_gt?: Int;
  aportaAFP_gte?: Int;
  AFP?: Int;
  AFP_not?: Int;
  AFP_in?: Int[] | Int;
  AFP_not_in?: Int[] | Int;
  AFP_lt?: Int;
  AFP_lte?: Int;
  AFP_gt?: Int;
  AFP_gte?: Int;
  cargo?: String;
  cargo_not?: String;
  cargo_in?: String[] | String;
  cargo_not_in?: String[] | String;
  cargo_lt?: String;
  cargo_lte?: String;
  cargo_gt?: String;
  cargo_gte?: String;
  cargo_contains?: String;
  cargo_not_contains?: String;
  cargo_starts_with?: String;
  cargo_not_starts_with?: String;
  cargo_ends_with?: String;
  cargo_not_ends_with?: String;
  zkTimePin?: Int;
  zkTimePin_not?: Int;
  zkTimePin_in?: Int[] | Int;
  zkTimePin_not_in?: Int[] | Int;
  zkTimePin_lt?: Int;
  zkTimePin_lte?: Int;
  zkTimePin_gt?: Int;
  zkTimePin_gte?: Int;
  department?: DepartmentWhereInput;
  shifts_every?: ShiftWhereInput;
  shifts_some?: ShiftWhereInput;
  shifts_none?: ShiftWhereInput;
  AND?: EmployeeWhereInput[] | EmployeeWhereInput;
  OR?: EmployeeWhereInput[] | EmployeeWhereInput;
  NOT?: EmployeeWhereInput[] | EmployeeWhereInput;
}

export interface ShiftSlotUpdateManyInput {
  create?: ShiftSlotCreateInput[] | ShiftSlotCreateInput;
  update?:
    | ShiftSlotUpdateWithWhereUniqueNestedInput[]
    | ShiftSlotUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ShiftSlotUpsertWithWhereUniqueNestedInput[]
    | ShiftSlotUpsertWithWhereUniqueNestedInput;
  delete?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
  connect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
  disconnect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
}

export type ScheduleOfflineElementWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ShiftSlotUpdateWithWhereUniqueNestedInput {
  where: ShiftSlotWhereUniqueInput;
  data: ShiftSlotUpdateDataInput;
}

export interface ExceptionSlotCreateInput {
  schedule: ScheduleCreateOneInput;
  date: DateTimeInput;
}

export interface ShiftSlotUpdateDataInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  index?: Int;
}

export interface ExceptionCreateInput {
  employee: EmployeeCreateOneInput;
  slots?: ExceptionSlotCreateManyInput;
  owner: UserCreateOneInput;
}

export interface ScheduleUpdateOneRequiredInput {
  create?: ScheduleCreateInput;
  update?: ScheduleUpdateDataInput;
  upsert?: ScheduleUpsertNestedInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ShiftUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ShiftWhereUniqueInput;
  update: ShiftUpdateWithoutEmployeeDataInput;
  create: ShiftCreateWithoutEmployeeInput;
}

export interface ScheduleUpdateDataInput {
  description?: String;
  baseTime?: Int;
  custom?: Boolean;
  timeline?: ScheduleTimelineElementUpdateManyInput;
  restline?: ScheduleRestlineElementUpdateManyInput;
  offline1?: ScheduleOfflineElementUpdateOneInput;
  offline2?: ScheduleOfflineElementUpdateOneInput;
}

export interface ScheduleWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  baseTime?: Int;
  baseTime_not?: Int;
  baseTime_in?: Int[] | Int;
  baseTime_not_in?: Int[] | Int;
  baseTime_lt?: Int;
  baseTime_lte?: Int;
  baseTime_gt?: Int;
  baseTime_gte?: Int;
  custom?: Boolean;
  custom_not?: Boolean;
  timeline_every?: ScheduleTimelineElementWhereInput;
  timeline_some?: ScheduleTimelineElementWhereInput;
  timeline_none?: ScheduleTimelineElementWhereInput;
  restline_every?: ScheduleRestlineElementWhereInput;
  restline_some?: ScheduleRestlineElementWhereInput;
  restline_none?: ScheduleRestlineElementWhereInput;
  offline1?: ScheduleOfflineElementWhereInput;
  offline2?: ScheduleOfflineElementWhereInput;
  AND?: ScheduleWhereInput[] | ScheduleWhereInput;
  OR?: ScheduleWhereInput[] | ScheduleWhereInput;
  NOT?: ScheduleWhereInput[] | ScheduleWhereInput;
}

export interface ScheduleTimelineElementUpdateManyInput {
  create?:
    | ScheduleTimelineElementCreateInput[]
    | ScheduleTimelineElementCreateInput;
  update?:
    | ScheduleTimelineElementUpdateWithWhereUniqueNestedInput[]
    | ScheduleTimelineElementUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ScheduleTimelineElementUpsertWithWhereUniqueNestedInput[]
    | ScheduleTimelineElementUpsertWithWhereUniqueNestedInput;
  delete?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
  connect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
  disconnect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
}

export interface ExceptionAuthorizationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionAuthorizationWhereInput;
  AND?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
  OR?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
  NOT?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
}

export interface ScheduleTimelineElementUpdateWithWhereUniqueNestedInput {
  where: ScheduleTimelineElementWhereUniqueInput;
  data: ScheduleTimelineElementUpdateDataInput;
}

export type ExceptionWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ScheduleTimelineElementUpdateDataInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  startRequireEvent?: Boolean;
  endTime?: Int;
  endRequireEvent?: Boolean;
}

export interface EmployeeCreateOneWithoutShiftsInput {
  create?: EmployeeCreateWithoutShiftsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleTimelineElementUpsertWithWhereUniqueNestedInput {
  where: ScheduleTimelineElementWhereUniqueInput;
  update: ScheduleTimelineElementUpdateDataInput;
  create: ScheduleTimelineElementCreateInput;
}

export interface ExceptionSlotUpdateInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  date?: DateTimeInput;
}

export interface ScheduleRestlineElementUpdateManyInput {
  create?:
    | ScheduleRestlineElementCreateInput[]
    | ScheduleRestlineElementCreateInput;
  update?:
    | ScheduleRestlineElementUpdateWithWhereUniqueNestedInput[]
    | ScheduleRestlineElementUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ScheduleRestlineElementUpsertWithWhereUniqueNestedInput[]
    | ScheduleRestlineElementUpsertWithWhereUniqueNestedInput;
  delete?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
  connect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
  disconnect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
}

export interface ExceptionSlotUpdateWithWhereUniqueNestedInput {
  where: ExceptionSlotWhereUniqueInput;
  data: ExceptionSlotUpdateDataInput;
}

export interface ScheduleRestlineElementUpdateWithWhereUniqueNestedInput {
  where: ScheduleRestlineElementWhereUniqueInput;
  data: ScheduleRestlineElementUpdateDataInput;
}

export interface ExceptionSlotCreateManyInput {
  create?: ExceptionSlotCreateInput[] | ExceptionSlotCreateInput;
  connect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
}

export interface ScheduleRestlineElementUpdateDataInput {
  category?: ScheduleRestlineCategory;
  startTime?: Int;
  startRequireEvent?: Boolean;
  endTime?: Int;
  endRequireEvent?: Boolean;
  duration?: Int;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ScheduleRestlineElementUpsertWithWhereUniqueNestedInput {
  where: ScheduleRestlineElementWhereUniqueInput;
  update: ScheduleRestlineElementUpdateDataInput;
  create: ScheduleRestlineElementCreateInput;
}

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: UUID;
}>;

export interface ScheduleOfflineElementUpdateOneInput {
  create?: ScheduleOfflineElementCreateInput;
  update?: ScheduleOfflineElementUpdateDataInput;
  upsert?: ScheduleOfflineElementUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScheduleOfflineElementWhereUniqueInput;
}

export interface ExceptionAuthorizationWhereInput {
  id?: UUID;
  id_not?: UUID;
  id_in?: UUID[] | UUID;
  id_not_in?: UUID[] | UUID;
  id_lt?: UUID;
  id_lte?: UUID;
  id_gt?: UUID;
  id_gte?: UUID;
  id_contains?: UUID;
  id_not_contains?: UUID;
  id_starts_with?: UUID;
  id_not_starts_with?: UUID;
  id_ends_with?: UUID;
  id_not_ends_with?: UUID;
  granted?: Boolean;
  granted_not?: Boolean;
  user?: UserWhereInput;
  AND?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
  OR?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
  NOT?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
}

export interface ScheduleOfflineElementUpdateDataInput {
  category?: ScheduleOfflineCategory;
}

export interface EmployeeUpdateOneRequiredInput {
  create?: EmployeeCreateInput;
  update?: EmployeeUpdateDataInput;
  upsert?: EmployeeUpsertNestedInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface ShiftSlotUpsertWithWhereUniqueNestedInput {
  where: ShiftSlotWhereUniqueInput;
  update: ShiftSlotUpdateDataInput;
  create: ShiftSlotCreateInput;
}

export interface ScheduleUpsertNestedInput {
  update: ScheduleUpdateDataInput;
  create: ScheduleCreateInput;
}

export interface ScheduleOfflineElementUpsertNestedInput {
  update: ScheduleOfflineElementUpdateDataInput;
  create: ScheduleOfflineElementCreateInput;
}

export interface EmployeeUpdateInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
}

export interface ExceptionSlotUpsertWithWhereUniqueNestedInput {
  where: ExceptionSlotWhereUniqueInput;
  update: ExceptionSlotUpdateDataInput;
  create: ExceptionSlotCreateInput;
}

export interface EmployeeUpdateOneRequiredWithoutShiftsInput {
  create?: EmployeeCreateWithoutShiftsInput;
  update?: EmployeeUpdateWithoutShiftsDataInput;
  upsert?: EmployeeUpsertWithoutShiftsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleWhereInput;
  AND?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  OR?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  NOT?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValuesNode {
  id: UUID;
  username: String;
  password: String;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  username: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEmployeeNode {
  count: Int;
}

export interface AggregateEmployee
  extends Promise<AggregateEmployeeNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployeeNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeNode {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeOutput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin: Int;
}

export interface Employee extends Promise<EmployeeNode>, Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nameFirst: () => Promise<String>;
  nameMiddle: () => Promise<String>;
  namePaternal: () => Promise<String>;
  nameMaternal: () => Promise<String>;
  documentType: () => Promise<DocumentTypeEnum>;
  documentNumber: () => Promise<String>;
  sex: () => Promise<SexEnum>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  nationality: () => Promise<String>;
  jubilado: () => Promise<Int>;
  personaConDiscapacidad: () => Promise<Int>;
  tutorPersonaConDiscapacidad: () => Promise<Int>;
  cajaDeSalud: () => Promise<Int>;
  aportaAFP: () => Promise<Int>;
  AFP: () => Promise<Int>;
  cargo: () => Promise<String>;
  zkTimePin: () => Promise<Int>;
  department: <T = Department>() => T;
  shifts: <T = FragmentableArray<ShiftNode>>(
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<EmployeeNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameMiddle: () => Promise<AsyncIterator<String>>;
  namePaternal: () => Promise<AsyncIterator<String>>;
  nameMaternal: () => Promise<AsyncIterator<String>>;
  documentType: () => Promise<AsyncIterator<DocumentTypeEnum>>;
  documentNumber: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<SexEnum>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  nationality: () => Promise<AsyncIterator<String>>;
  jubilado: () => Promise<AsyncIterator<Int>>;
  personaConDiscapacidad: () => Promise<AsyncIterator<Int>>;
  tutorPersonaConDiscapacidad: () => Promise<AsyncIterator<Int>>;
  cajaDeSalud: () => Promise<AsyncIterator<Int>>;
  aportaAFP: () => Promise<AsyncIterator<Int>>;
  AFP: () => Promise<AsyncIterator<Int>>;
  cargo: () => Promise<AsyncIterator<String>>;
  zkTimePin: () => Promise<AsyncIterator<Int>>;
  department: <T = DepartmentSubscription>() => T;
  shifts: <T = Promise<AsyncIterator<ShiftSubscription>>>(
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EmployeeEdgeNode {
  cursor: String;
}

export interface EmployeeEdge extends Promise<EmployeeEdgeNode>, Fragmentable {
  node: <T = Employee>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdgeNode>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeConnectionNode {}

export interface EmployeeConnection
  extends Promise<EmployeeConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<EmployeeEdgeNode>>() => T;
  aggregate: <T = AggregateEmployee>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdgeNode>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateDepartmentNode {
  count: Int;
}

export interface AggregateDepartment
  extends Promise<AggregateDepartmentNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartmentNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ShiftSlotEdgeNode {
  cursor: String;
}

export interface ShiftSlotEdge
  extends Promise<ShiftSlotEdgeNode>,
    Fragmentable {
  node: <T = ShiftSlot>() => T;
  cursor: () => Promise<String>;
}

export interface ShiftSlotEdgeSubscription
  extends Promise<AsyncIterator<ShiftSlotEdgeNode>>,
    Fragmentable {
  node: <T = ShiftSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentNode {
  id: UUID;
  name: String;
}

export interface Department extends Promise<DepartmentNode>, Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
  subordinates: <T = FragmentableArray<EmployeeNode>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  supervisors: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<DepartmentNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
  subordinates: <T = Promise<AsyncIterator<EmployeeSubscription>>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  supervisors: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateShiftNode {
  count: Int;
}

export interface AggregateShift
  extends Promise<AggregateShiftNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShiftSubscription
  extends Promise<AsyncIterator<AggregateShiftNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DepartmentSubscriptionPayload
  extends Promise<DepartmentSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Department>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValues>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface ShiftConnectionNode {}

export interface ShiftConnection
  extends Promise<ShiftConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ShiftEdgeNode>>() => T;
  aggregate: <T = AggregateShift>() => T;
}

export interface ShiftConnectionSubscription
  extends Promise<AsyncIterator<ShiftConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShiftEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShiftSubscription>() => T;
}

export interface DepartmentPreviousValuesNode {
  id: UUID;
  name: String;
}

export interface DepartmentPreviousValues
  extends Promise<DepartmentPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  name: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleTimelineElementEdgeNode {
  cursor: String;
}

export interface ScheduleTimelineElementEdge
  extends Promise<ScheduleTimelineElementEdgeNode>,
    Fragmentable {
  node: <T = ScheduleTimelineElement>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleTimelineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementEdgeNode>>,
    Fragmentable {
  node: <T = ScheduleTimelineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ShiftEdgeNode {
  cursor: String;
}

export interface ShiftEdge extends Promise<ShiftEdgeNode>, Fragmentable {
  node: <T = Shift>() => T;
  cursor: () => Promise<String>;
}

export interface ShiftEdgeSubscription
  extends Promise<AsyncIterator<ShiftEdgeNode>>,
    Fragmentable {
  node: <T = ShiftSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ShiftPreviousValuesNode {
  id: UUID;
  description?: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
  startIndex: Int;
}

export interface ShiftPreviousValues
  extends Promise<ShiftPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  startIndex: () => Promise<Int>;
}

export interface ShiftPreviousValuesSubscription
  extends Promise<AsyncIterator<ShiftPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  description: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startIndex: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateScheduleTimelineElementNode {
  count: Int;
}

export interface AggregateScheduleTimelineElement
  extends Promise<AggregateScheduleTimelineElementNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleTimelineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleTimelineElementNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentEdgeNode {
  cursor: String;
}

export interface DepartmentEdge
  extends Promise<DepartmentEdgeNode>,
    Fragmentable {
  node: <T = Department>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdgeNode>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ScheduleRestlineElementEdgeNode {
  cursor: String;
}

export interface ScheduleRestlineElementEdge
  extends Promise<ScheduleRestlineElementEdgeNode>,
    Fragmentable {
  node: <T = ScheduleRestlineElement>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleRestlineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementEdgeNode>>,
    Fragmentable {
  node: <T = ScheduleRestlineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleTimelineElementConnectionNode {}

export interface ScheduleTimelineElementConnection
  extends Promise<ScheduleTimelineElementConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleTimelineElementEdgeNode>>() => T;
  aggregate: <T = AggregateScheduleTimelineElement>() => T;
}

export interface ScheduleTimelineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleTimelineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleTimelineElementSubscription>() => T;
}

export interface AggregateScheduleOfflineElementNode {
  count: Int;
}

export interface AggregateScheduleOfflineElement
  extends Promise<AggregateScheduleOfflineElementNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleOfflineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleOfflineElementNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeeSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EmployeeSubscriptionPayload
  extends Promise<EmployeeSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Employee>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValues>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface ScheduleOfflineElementConnectionNode {}

export interface ScheduleOfflineElementConnection
  extends Promise<ScheduleOfflineElementConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleOfflineElementEdgeNode>>() => T;
  aggregate: <T = AggregateScheduleOfflineElement>() => T;
}

export interface ScheduleOfflineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleOfflineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleOfflineElementSubscription>() => T;
}

export interface EmployeePreviousValuesNode {
  id: UUID;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: DocumentTypeEnum;
  documentNumber?: String;
  sex?: SexEnum;
  dateOfBirth?: DateTimeOutput;
  nationality?: String;
  jubilado?: Int;
  personaConDiscapacidad?: Int;
  tutorPersonaConDiscapacidad?: Int;
  cajaDeSalud?: Int;
  aportaAFP?: Int;
  AFP?: Int;
  cargo?: String;
  zkTimePin: Int;
}

export interface EmployeePreviousValues
  extends Promise<EmployeePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nameFirst: () => Promise<String>;
  nameMiddle: () => Promise<String>;
  namePaternal: () => Promise<String>;
  nameMaternal: () => Promise<String>;
  documentType: () => Promise<DocumentTypeEnum>;
  documentNumber: () => Promise<String>;
  sex: () => Promise<SexEnum>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  nationality: () => Promise<String>;
  jubilado: () => Promise<Int>;
  personaConDiscapacidad: () => Promise<Int>;
  tutorPersonaConDiscapacidad: () => Promise<Int>;
  cajaDeSalud: () => Promise<Int>;
  aportaAFP: () => Promise<Int>;
  AFP: () => Promise<Int>;
  cargo: () => Promise<String>;
  zkTimePin: () => Promise<Int>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameMiddle: () => Promise<AsyncIterator<String>>;
  namePaternal: () => Promise<AsyncIterator<String>>;
  nameMaternal: () => Promise<AsyncIterator<String>>;
  documentType: () => Promise<AsyncIterator<DocumentTypeEnum>>;
  documentNumber: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<SexEnum>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  nationality: () => Promise<AsyncIterator<String>>;
  jubilado: () => Promise<AsyncIterator<Int>>;
  personaConDiscapacidad: () => Promise<AsyncIterator<Int>>;
  tutorPersonaConDiscapacidad: () => Promise<AsyncIterator<Int>>;
  cajaDeSalud: () => Promise<AsyncIterator<Int>>;
  aportaAFP: () => Promise<AsyncIterator<Int>>;
  AFP: () => Promise<AsyncIterator<Int>>;
  cargo: () => Promise<AsyncIterator<String>>;
  zkTimePin: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateScheduleNode {
  count: Int;
}

export interface AggregateSchedule
  extends Promise<AggregateScheduleNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleSubscription
  extends Promise<AsyncIterator<AggregateScheduleNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleConnectionNode {}

export interface ScheduleConnection
  extends Promise<ScheduleConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleEdgeNode>>() => T;
  aggregate: <T = AggregateSchedule>() => T;
}

export interface ScheduleConnectionSubscription
  extends Promise<AsyncIterator<ScheduleConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleSubscription>() => T;
}

export interface ExceptionSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionSubscriptionPayload
  extends Promise<ExceptionSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Exception>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionPreviousValues>() => T;
}

export interface ExceptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionPreviousValuesSubscription>() => T;
}

export interface ExceptionSlotEdgeNode {
  cursor: String;
}

export interface ExceptionSlotEdge
  extends Promise<ExceptionSlotEdgeNode>,
    Fragmentable {
  node: <T = ExceptionSlot>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionSlotEdgeSubscription
  extends Promise<AsyncIterator<ExceptionSlotEdgeNode>>,
    Fragmentable {
  node: <T = ExceptionSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionPreviousValuesNode {
  id: UUID;
}

export interface ExceptionPreviousValues
  extends Promise<ExceptionPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
}

export interface ExceptionPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
}

export interface AggregateExceptionAuthorizationNode {
  count: Int;
}

export interface AggregateExceptionAuthorization
  extends Promise<AggregateExceptionAuthorizationNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionAuthorizationSubscription
  extends Promise<AsyncIterator<AggregateExceptionAuthorizationNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DepartmentConnectionNode {}

export interface DepartmentConnection
  extends Promise<DepartmentConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DepartmentEdgeNode>>() => T;
  aggregate: <T = AggregateDepartment>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface ExceptionAuthorizationConnectionNode {}

export interface ExceptionAuthorizationConnection
  extends Promise<ExceptionAuthorizationConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExceptionAuthorizationEdgeNode>>() => T;
  aggregate: <T = AggregateExceptionAuthorization>() => T;
}

export interface ExceptionAuthorizationConnectionSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExceptionAuthorizationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExceptionAuthorizationSubscription>() => T;
}

export interface ExceptionAuthorizationSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionAuthorizationSubscriptionPayload
  extends Promise<ExceptionAuthorizationSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionAuthorization>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionAuthorizationPreviousValues>() => T;
}

export interface ExceptionAuthorizationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionAuthorizationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionAuthorizationPreviousValuesSubscription>() => T;
}

export interface ExceptionAuthorizationNode {
  id: UUID;
  granted: Boolean;
}

export interface ExceptionAuthorization
  extends Promise<ExceptionAuthorizationNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  granted: () => Promise<Boolean>;
  user: <T = User>() => T;
}

export interface ExceptionAuthorizationSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  granted: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
}

export interface ExceptionAuthorizationPreviousValuesNode {
  id: UUID;
  granted: Boolean;
}

export interface ExceptionAuthorizationPreviousValues
  extends Promise<ExceptionAuthorizationPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  granted: () => Promise<Boolean>;
}

export interface ExceptionAuthorizationPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  granted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExceptionEdgeNode {
  cursor: String;
}

export interface ExceptionEdge
  extends Promise<ExceptionEdgeNode>,
    Fragmentable {
  node: <T = Exception>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionEdgeSubscription
  extends Promise<AsyncIterator<ExceptionEdgeNode>>,
    Fragmentable {
  node: <T = ExceptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserNode {
  id: UUID;
  username: String;
  password: String;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<UUID>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  departments: <T = FragmentableArray<EmployeeNode>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  departments: <T = Promise<AsyncIterator<EmployeeSubscription>>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ShiftSlotPreviousValuesNode {
  id: UUID;
  index: Int;
}

export interface ShiftSlotPreviousValues
  extends Promise<ShiftSlotPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  index: () => Promise<Int>;
}

export interface ShiftSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<ShiftSlotPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  index: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionSlotSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionSlotSubscriptionPayload
  extends Promise<ExceptionSlotSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionSlot>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionSlotPreviousValues>() => T;
}

export interface ExceptionSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionSlotSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionSlotPreviousValuesSubscription>() => T;
}

export interface ExceptionNode {
  id: UUID;
}

export interface Exception extends Promise<ExceptionNode>, Fragmentable {
  id: () => Promise<UUID>;
  employee: <T = Employee>() => T;
  slots: <T = FragmentableArray<ExceptionSlotNode>>(
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = User>() => T;
}

export interface ExceptionSubscription
  extends Promise<AsyncIterator<ExceptionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  employee: <T = EmployeeSubscription>() => T;
  slots: <T = Promise<AsyncIterator<ExceptionSlotSubscription>>>(
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserSubscription>() => T;
}

export interface ExceptionSlotPreviousValuesNode {
  id: UUID;
  date: DateTimeOutput;
}

export interface ExceptionSlotPreviousValues
  extends Promise<ExceptionSlotPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  date: () => Promise<DateTimeOutput>;
}

export interface ExceptionSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionSlotPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleOfflineElementNode {
  id: UUID;
  category: ScheduleOfflineCategory;
}

export interface ScheduleOfflineElement
  extends Promise<ScheduleOfflineElementNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  category: () => Promise<ScheduleOfflineCategory>;
}

export interface ScheduleOfflineElementSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
}

export interface ShiftSlotConnectionNode {}

export interface ShiftSlotConnection
  extends Promise<ShiftSlotConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ShiftSlotEdgeNode>>() => T;
  aggregate: <T = AggregateShiftSlot>() => T;
}

export interface ShiftSlotConnectionSubscription
  extends Promise<AsyncIterator<ShiftSlotConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShiftSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShiftSlotSubscription>() => T;
}

export interface ScheduleSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleSubscriptionPayload
  extends Promise<ScheduleSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Schedule>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchedulePreviousValues>() => T;
}

export interface ScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchedulePreviousValuesSubscription>() => T;
}

export interface ScheduleRestlineElementConnectionNode {}

export interface ScheduleRestlineElementConnection
  extends Promise<ScheduleRestlineElementConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleRestlineElementEdgeNode>>() => T;
  aggregate: <T = AggregateScheduleRestlineElement>() => T;
}

export interface ScheduleRestlineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleRestlineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleRestlineElementSubscription>() => T;
}

export interface SchedulePreviousValuesNode {
  id: UUID;
  description?: String;
  baseTime: Int;
  custom: Boolean;
}

export interface SchedulePreviousValues
  extends Promise<SchedulePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  description: () => Promise<String>;
  baseTime: () => Promise<Int>;
  custom: () => Promise<Boolean>;
}

export interface SchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SchedulePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  description: () => Promise<AsyncIterator<String>>;
  baseTime: () => Promise<AsyncIterator<Int>>;
  custom: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ScheduleRestlineElementNode {
  id: UUID;
  category: ScheduleRestlineCategory;
  startTime: Int;
  startRequireEvent: Boolean;
  endTime: Int;
  endRequireEvent: Boolean;
  duration: Int;
}

export interface ScheduleRestlineElement
  extends Promise<ScheduleRestlineElementNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  category: () => Promise<ScheduleRestlineCategory>;
  startTime: () => Promise<Int>;
  startRequireEvent: () => Promise<Boolean>;
  endTime: () => Promise<Int>;
  endRequireEvent: () => Promise<Boolean>;
  duration: () => Promise<Int>;
}

export interface ScheduleRestlineElementSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  category: () => Promise<AsyncIterator<ScheduleRestlineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  startRequireEvent: () => Promise<AsyncIterator<Boolean>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  endRequireEvent: () => Promise<AsyncIterator<Boolean>>;
  duration: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateExceptionSlotNode {
  count: Int;
}

export interface AggregateExceptionSlot
  extends Promise<AggregateExceptionSlotNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionSlotSubscription
  extends Promise<AsyncIterator<AggregateExceptionSlotNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleOfflineElementSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleOfflineElementSubscriptionPayload
  extends Promise<ScheduleOfflineElementSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleOfflineElement>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleOfflineElementPreviousValues>() => T;
}

export interface ScheduleOfflineElementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleOfflineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleOfflineElementPreviousValuesSubscription>() => T;
}

export interface ExceptionAuthorizationEdgeNode {
  cursor: String;
}

export interface ExceptionAuthorizationEdge
  extends Promise<ExceptionAuthorizationEdgeNode>,
    Fragmentable {
  node: <T = ExceptionAuthorization>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionAuthorizationEdgeSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationEdgeNode>>,
    Fragmentable {
  node: <T = ExceptionAuthorizationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleOfflineElementPreviousValuesNode {
  id: UUID;
  category: ScheduleOfflineCategory;
}

export interface ScheduleOfflineElementPreviousValues
  extends Promise<ScheduleOfflineElementPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  category: () => Promise<ScheduleOfflineCategory>;
}

export interface ScheduleOfflineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
}

export interface AggregateExceptionNode {
  count: Int;
}

export interface AggregateException
  extends Promise<AggregateExceptionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionSubscription
  extends Promise<AsyncIterator<AggregateExceptionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleTimelineElementNode {
  id: UUID;
  category: ScheduleTimelineCategory;
  startTime: Int;
  startRequireEvent: Boolean;
  endTime: Int;
  endRequireEvent: Boolean;
}

export interface ScheduleTimelineElement
  extends Promise<ScheduleTimelineElementNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  category: () => Promise<ScheduleTimelineCategory>;
  startTime: () => Promise<Int>;
  startRequireEvent: () => Promise<Boolean>;
  endTime: () => Promise<Int>;
  endRequireEvent: () => Promise<Boolean>;
}

export interface ScheduleTimelineElementSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  category: () => Promise<AsyncIterator<ScheduleTimelineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  startRequireEvent: () => Promise<AsyncIterator<Boolean>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  endRequireEvent: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExceptionSlotNode {
  id: UUID;
  date: DateTimeOutput;
}

export interface ExceptionSlot
  extends Promise<ExceptionSlotNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  schedule: <T = Schedule>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface ExceptionSlotSubscription
  extends Promise<AsyncIterator<ExceptionSlotNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  schedule: <T = ScheduleSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ScheduleRestlineElementSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleRestlineElementSubscriptionPayload
  extends Promise<ScheduleRestlineElementSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleRestlineElement>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleRestlineElementPreviousValues>() => T;
}

export interface ScheduleRestlineElementSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<ScheduleRestlineElementSubscriptionPayloadNode>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleRestlineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ScheduleRestlineElementPreviousValuesSubscription
  >() => T;
}

export interface AggregateShiftSlotNode {
  count: Int;
}

export interface AggregateShiftSlot
  extends Promise<AggregateShiftSlotNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShiftSlotSubscription
  extends Promise<AsyncIterator<AggregateShiftSlotNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleRestlineElementPreviousValuesNode {
  id: UUID;
  category: ScheduleRestlineCategory;
  startTime: Int;
  startRequireEvent: Boolean;
  endTime: Int;
  endRequireEvent: Boolean;
  duration: Int;
}

export interface ScheduleRestlineElementPreviousValues
  extends Promise<ScheduleRestlineElementPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  category: () => Promise<ScheduleRestlineCategory>;
  startTime: () => Promise<Int>;
  startRequireEvent: () => Promise<Boolean>;
  endTime: () => Promise<Int>;
  endRequireEvent: () => Promise<Boolean>;
  duration: () => Promise<Int>;
}

export interface ScheduleRestlineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  category: () => Promise<AsyncIterator<ScheduleRestlineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  startRequireEvent: () => Promise<AsyncIterator<Boolean>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  endRequireEvent: () => Promise<AsyncIterator<Boolean>>;
  duration: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleOfflineElementEdgeNode {
  cursor: String;
}

export interface ScheduleOfflineElementEdge
  extends Promise<ScheduleOfflineElementEdgeNode>,
    Fragmentable {
  node: <T = ScheduleOfflineElement>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleOfflineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementEdgeNode>>,
    Fragmentable {
  node: <T = ScheduleOfflineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleNode {
  id: UUID;
  description?: String;
  baseTime: Int;
  custom: Boolean;
}

export interface Schedule extends Promise<ScheduleNode>, Fragmentable {
  id: () => Promise<UUID>;
  description: () => Promise<String>;
  baseTime: () => Promise<Int>;
  custom: () => Promise<Boolean>;
  timeline: <T = FragmentableArray<ScheduleTimelineElementNode>>(
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  restline: <T = FragmentableArray<ScheduleRestlineElementNode>>(
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  offline1: <T = ScheduleOfflineElement>() => T;
  offline2: <T = ScheduleOfflineElement>() => T;
}

export interface ScheduleSubscription
  extends Promise<AsyncIterator<ScheduleNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  description: () => Promise<AsyncIterator<String>>;
  baseTime: () => Promise<AsyncIterator<Int>>;
  custom: () => Promise<AsyncIterator<Boolean>>;
  timeline: <T = Promise<AsyncIterator<ScheduleTimelineElementSubscription>>>(
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  restline: <T = Promise<AsyncIterator<ScheduleRestlineElementSubscription>>>(
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  offline1: <T = ScheduleOfflineElementSubscription>() => T;
  offline2: <T = ScheduleOfflineElementSubscription>() => T;
}

export interface ExceptionSlotConnectionNode {}

export interface ExceptionSlotConnection
  extends Promise<ExceptionSlotConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExceptionSlotEdgeNode>>() => T;
  aggregate: <T = AggregateExceptionSlot>() => T;
}

export interface ExceptionSlotConnectionSubscription
  extends Promise<AsyncIterator<ExceptionSlotConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExceptionSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExceptionSlotSubscription>() => T;
}

export interface ExceptionConnectionNode {}

export interface ExceptionConnection
  extends Promise<ExceptionConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExceptionEdgeNode>>() => T;
  aggregate: <T = AggregateException>() => T;
}

export interface ExceptionConnectionSubscription
  extends Promise<AsyncIterator<ExceptionConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExceptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExceptionSubscription>() => T;
}

export interface ShiftSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ShiftSubscriptionPayload
  extends Promise<ShiftSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Shift>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShiftPreviousValues>() => T;
}

export interface ShiftSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShiftSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShiftSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShiftPreviousValuesSubscription>() => T;
}

export interface ShiftSlotNode {
  id: UUID;
  index: Int;
}

export interface ShiftSlot extends Promise<ShiftSlotNode>, Fragmentable {
  id: () => Promise<UUID>;
  schedule: <T = Schedule>() => T;
  index: () => Promise<Int>;
}

export interface ShiftSlotSubscription
  extends Promise<AsyncIterator<ShiftSlotNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  schedule: <T = ScheduleSubscription>() => T;
  index: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleTimelineElementPreviousValuesNode {
  id: UUID;
  category: ScheduleTimelineCategory;
  startTime: Int;
  startRequireEvent: Boolean;
  endTime: Int;
  endRequireEvent: Boolean;
}

export interface ScheduleTimelineElementPreviousValues
  extends Promise<ScheduleTimelineElementPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<UUID>;
  category: () => Promise<ScheduleTimelineCategory>;
  startTime: () => Promise<Int>;
  startRequireEvent: () => Promise<Boolean>;
  endTime: () => Promise<Int>;
  endRequireEvent: () => Promise<Boolean>;
}

export interface ScheduleTimelineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  category: () => Promise<AsyncIterator<ScheduleTimelineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  startRequireEvent: () => Promise<AsyncIterator<Boolean>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  endRequireEvent: () => Promise<AsyncIterator<Boolean>>;
}

export interface ScheduleTimelineElementSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleTimelineElementSubscriptionPayload
  extends Promise<ScheduleTimelineElementSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleTimelineElement>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleTimelineElementPreviousValues>() => T;
}

export interface ScheduleTimelineElementSubscriptionPayloadSubscription
  extends Promise<
      AsyncIterator<ScheduleTimelineElementSubscriptionPayloadNode>
    >,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleTimelineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ScheduleTimelineElementPreviousValuesSubscription
  >() => T;
}

export interface ShiftSlotSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ShiftSlotSubscriptionPayload
  extends Promise<ShiftSlotSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShiftSlot>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShiftSlotPreviousValues>() => T;
}

export interface ShiftSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShiftSlotSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShiftSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShiftSlotPreviousValuesSubscription>() => T;
}

export interface ShiftNode {
  id: UUID;
  description?: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
  startIndex: Int;
}

export interface Shift extends Promise<ShiftNode>, Fragmentable {
  id: () => Promise<UUID>;
  description: () => Promise<String>;
  employee: <T = Employee>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  startIndex: () => Promise<Int>;
  slots: <T = FragmentableArray<ShiftSlotNode>>(
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = User>() => T;
}

export interface ShiftSubscription
  extends Promise<AsyncIterator<ShiftNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<UUID>>;
  description: () => Promise<AsyncIterator<String>>;
  employee: <T = EmployeeSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  startIndex: () => Promise<AsyncIterator<Int>>;
  slots: <T = Promise<AsyncIterator<ShiftSlotSubscription>>>(
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserSubscription>() => T;
}

export interface ScheduleEdgeNode {
  cursor: String;
}

export interface ScheduleEdge extends Promise<ScheduleEdgeNode>, Fragmentable {
  node: <T = Schedule>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleEdgeSubscription
  extends Promise<AsyncIterator<ScheduleEdgeNode>>,
    Fragmentable {
  node: <T = ScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScheduleRestlineElementNode {
  count: Int;
}

export interface AggregateScheduleRestlineElement
  extends Promise<AggregateScheduleRestlineElementNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleRestlineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleRestlineElementNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export type UUID = string;

export type Long = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Type Defs
 */

export const prisma: Prisma;
