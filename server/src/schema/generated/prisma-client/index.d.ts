// Code generated by Prisma (prisma@1.20.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  attendanceCycle: (where?: AttendanceCycleWhereInput) => Promise<boolean>;
  department: (where?: DepartmentWhereInput) => Promise<boolean>;
  directCredit: (where?: DirectCreditWhereInput) => Promise<boolean>;
  employee: (where?: EmployeeWhereInput) => Promise<boolean>;
  exception: (where?: ExceptionWhereInput) => Promise<boolean>;
  exceptionAuthorization: (
    where?: ExceptionAuthorizationWhereInput
  ) => Promise<boolean>;
  exceptionSlot: (where?: ExceptionSlotWhereInput) => Promise<boolean>;
  fieldOptionLabel: (where?: FieldOptionLabelWhereInput) => Promise<boolean>;
  holiday: (where?: HolidayWhereInput) => Promise<boolean>;
  schedule: (where?: ScheduleWhereInput) => Promise<boolean>;
  scheduleCategoryConfig: (
    where?: ScheduleCategoryConfigWhereInput
  ) => Promise<boolean>;
  scheduleCredit: (where?: ScheduleCreditWhereInput) => Promise<boolean>;
  scheduleDebit: (where?: ScheduleDebitWhereInput) => Promise<boolean>;
  scheduleOfflineElement: (
    where?: ScheduleOfflineElementWhereInput
  ) => Promise<boolean>;
  scheduleRestlineElement: (
    where?: ScheduleRestlineElementWhereInput
  ) => Promise<boolean>;
  scheduleTimelineElement: (
    where?: ScheduleTimelineElementWhereInput
  ) => Promise<boolean>;
  shift: (where?: ShiftWhereInput) => Promise<boolean>;
  shiftSlot: (where?: ShiftSlotWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userRole: (where?: UserRoleWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attendanceCycle: (
    where: AttendanceCycleWhereUniqueInput
  ) => AttendanceCyclePromise;
  attendanceCycles: (
    args?: {
      where?: AttendanceCycleWhereInput;
      orderBy?: AttendanceCycleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<AttendanceCycle>;
  attendanceCyclesConnection: (
    args?: {
      where?: AttendanceCycleWhereInput;
      orderBy?: AttendanceCycleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AttendanceCycleConnectionPromise;
  department: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  departments: (
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Department>;
  departmentsConnection: (
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DepartmentConnectionPromise;
  directCredit: (where: DirectCreditWhereUniqueInput) => DirectCreditPromise;
  directCredits: (
    args?: {
      where?: DirectCreditWhereInput;
      orderBy?: DirectCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DirectCredit>;
  directCreditsConnection: (
    args?: {
      where?: DirectCreditWhereInput;
      orderBy?: DirectCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DirectCreditConnectionPromise;
  employee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  employees: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Employee>;
  employeesConnection: (
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EmployeeConnectionPromise;
  exception: (where: ExceptionWhereUniqueInput) => ExceptionPromise;
  exceptions: (
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Exception>;
  exceptionsConnection: (
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionConnectionPromise;
  exceptionAuthorization: (
    where: ExceptionAuthorizationWhereUniqueInput
  ) => ExceptionAuthorizationPromise;
  exceptionAuthorizations: (
    args?: {
      where?: ExceptionAuthorizationWhereInput;
      orderBy?: ExceptionAuthorizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionAuthorization>;
  exceptionAuthorizationsConnection: (
    args?: {
      where?: ExceptionAuthorizationWhereInput;
      orderBy?: ExceptionAuthorizationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionAuthorizationConnectionPromise;
  exceptionSlot: (where: ExceptionSlotWhereUniqueInput) => ExceptionSlotPromise;
  exceptionSlots: (
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ExceptionSlot>;
  exceptionSlotsConnection: (
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ExceptionSlotConnectionPromise;
  fieldOptionLabel: (
    where: FieldOptionLabelWhereUniqueInput
  ) => FieldOptionLabelPromise;
  fieldOptionLabels: (
    args?: {
      where?: FieldOptionLabelWhereInput;
      orderBy?: FieldOptionLabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<FieldOptionLabel>;
  fieldOptionLabelsConnection: (
    args?: {
      where?: FieldOptionLabelWhereInput;
      orderBy?: FieldOptionLabelOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FieldOptionLabelConnectionPromise;
  holiday: (where: HolidayWhereUniqueInput) => HolidayPromise;
  holidays: (
    args?: {
      where?: HolidayWhereInput;
      orderBy?: HolidayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Holiday>;
  holidaysConnection: (
    args?: {
      where?: HolidayWhereInput;
      orderBy?: HolidayOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HolidayConnectionPromise;
  schedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  schedules: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Schedule>;
  schedulesConnection: (
    args?: {
      where?: ScheduleWhereInput;
      orderBy?: ScheduleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleConnectionPromise;
  scheduleCategoryConfig: (
    where: ScheduleCategoryConfigWhereUniqueInput
  ) => ScheduleCategoryConfigPromise;
  scheduleCategoryConfigs: (
    args?: {
      where?: ScheduleCategoryConfigWhereInput;
      orderBy?: ScheduleCategoryConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleCategoryConfig>;
  scheduleCategoryConfigsConnection: (
    args?: {
      where?: ScheduleCategoryConfigWhereInput;
      orderBy?: ScheduleCategoryConfigOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleCategoryConfigConnectionPromise;
  scheduleCredit: (
    where: ScheduleCreditWhereUniqueInput
  ) => ScheduleCreditPromise;
  scheduleCredits: (
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleCredit>;
  scheduleCreditsConnection: (
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleCreditConnectionPromise;
  scheduleDebit: (where: ScheduleDebitWhereUniqueInput) => ScheduleDebitPromise;
  scheduleDebits: (
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleDebit>;
  scheduleDebitsConnection: (
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleDebitConnectionPromise;
  scheduleOfflineElement: (
    where: ScheduleOfflineElementWhereUniqueInput
  ) => ScheduleOfflineElementPromise;
  scheduleOfflineElements: (
    args?: {
      where?: ScheduleOfflineElementWhereInput;
      orderBy?: ScheduleOfflineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleOfflineElement>;
  scheduleOfflineElementsConnection: (
    args?: {
      where?: ScheduleOfflineElementWhereInput;
      orderBy?: ScheduleOfflineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleOfflineElementConnectionPromise;
  scheduleRestlineElement: (
    where: ScheduleRestlineElementWhereUniqueInput
  ) => ScheduleRestlineElementPromise;
  scheduleRestlineElements: (
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleRestlineElement>;
  scheduleRestlineElementsConnection: (
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleRestlineElementConnectionPromise;
  scheduleTimelineElement: (
    where: ScheduleTimelineElementWhereUniqueInput
  ) => ScheduleTimelineElementPromise;
  scheduleTimelineElements: (
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ScheduleTimelineElement>;
  scheduleTimelineElementsConnection: (
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ScheduleTimelineElementConnectionPromise;
  shift: (where: ShiftWhereUniqueInput) => ShiftPromise;
  shifts: (
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Shift>;
  shiftsConnection: (
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShiftConnectionPromise;
  shiftSlot: (where: ShiftSlotWhereUniqueInput) => ShiftSlotPromise;
  shiftSlots: (
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ShiftSlot>;
  shiftSlotsConnection: (
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ShiftSlotConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  userRoles: (
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserRole>;
  userRolesConnection: (
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserRoleConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttendanceCycle: (
    data: AttendanceCycleCreateInput
  ) => AttendanceCyclePromise;
  updateAttendanceCycle: (
    args: {
      data: AttendanceCycleUpdateInput;
      where: AttendanceCycleWhereUniqueInput;
    }
  ) => AttendanceCyclePromise;
  updateManyAttendanceCycles: (
    args: {
      data: AttendanceCycleUpdateManyMutationInput;
      where?: AttendanceCycleWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertAttendanceCycle: (
    args: {
      where: AttendanceCycleWhereUniqueInput;
      create: AttendanceCycleCreateInput;
      update: AttendanceCycleUpdateInput;
    }
  ) => AttendanceCyclePromise;
  deleteAttendanceCycle: (
    where: AttendanceCycleWhereUniqueInput
  ) => AttendanceCyclePromise;
  deleteManyAttendanceCycles: (
    where?: AttendanceCycleWhereInput
  ) => BatchPayloadPromise;
  createDepartment: (data: DepartmentCreateInput) => DepartmentPromise;
  updateDepartment: (
    args: { data: DepartmentUpdateInput; where: DepartmentWhereUniqueInput }
  ) => DepartmentPromise;
  updateManyDepartments: (
    args: {
      data: DepartmentUpdateManyMutationInput;
      where?: DepartmentWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDepartment: (
    args: {
      where: DepartmentWhereUniqueInput;
      create: DepartmentCreateInput;
      update: DepartmentUpdateInput;
    }
  ) => DepartmentPromise;
  deleteDepartment: (where: DepartmentWhereUniqueInput) => DepartmentPromise;
  deleteManyDepartments: (where?: DepartmentWhereInput) => BatchPayloadPromise;
  createDirectCredit: (data: DirectCreditCreateInput) => DirectCreditPromise;
  updateDirectCredit: (
    args: { data: DirectCreditUpdateInput; where: DirectCreditWhereUniqueInput }
  ) => DirectCreditPromise;
  updateManyDirectCredits: (
    args: {
      data: DirectCreditUpdateManyMutationInput;
      where?: DirectCreditWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertDirectCredit: (
    args: {
      where: DirectCreditWhereUniqueInput;
      create: DirectCreditCreateInput;
      update: DirectCreditUpdateInput;
    }
  ) => DirectCreditPromise;
  deleteDirectCredit: (
    where: DirectCreditWhereUniqueInput
  ) => DirectCreditPromise;
  deleteManyDirectCredits: (
    where?: DirectCreditWhereInput
  ) => BatchPayloadPromise;
  createEmployee: (data: EmployeeCreateInput) => EmployeePromise;
  updateEmployee: (
    args: { data: EmployeeUpdateInput; where: EmployeeWhereUniqueInput }
  ) => EmployeePromise;
  updateManyEmployees: (
    args: { data: EmployeeUpdateManyMutationInput; where?: EmployeeWhereInput }
  ) => BatchPayloadPromise;
  upsertEmployee: (
    args: {
      where: EmployeeWhereUniqueInput;
      create: EmployeeCreateInput;
      update: EmployeeUpdateInput;
    }
  ) => EmployeePromise;
  deleteEmployee: (where: EmployeeWhereUniqueInput) => EmployeePromise;
  deleteManyEmployees: (where?: EmployeeWhereInput) => BatchPayloadPromise;
  createException: (data: ExceptionCreateInput) => ExceptionPromise;
  updateException: (
    args: { data: ExceptionUpdateInput; where: ExceptionWhereUniqueInput }
  ) => ExceptionPromise;
  updateManyExceptions: (
    args: {
      data: ExceptionUpdateManyMutationInput;
      where?: ExceptionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertException: (
    args: {
      where: ExceptionWhereUniqueInput;
      create: ExceptionCreateInput;
      update: ExceptionUpdateInput;
    }
  ) => ExceptionPromise;
  deleteException: (where: ExceptionWhereUniqueInput) => ExceptionPromise;
  deleteManyExceptions: (where?: ExceptionWhereInput) => BatchPayloadPromise;
  createExceptionAuthorization: (
    data: ExceptionAuthorizationCreateInput
  ) => ExceptionAuthorizationPromise;
  updateExceptionAuthorization: (
    args: {
      data: ExceptionAuthorizationUpdateInput;
      where: ExceptionAuthorizationWhereUniqueInput;
    }
  ) => ExceptionAuthorizationPromise;
  updateManyExceptionAuthorizations: (
    args: {
      data: ExceptionAuthorizationUpdateManyMutationInput;
      where?: ExceptionAuthorizationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExceptionAuthorization: (
    args: {
      where: ExceptionAuthorizationWhereUniqueInput;
      create: ExceptionAuthorizationCreateInput;
      update: ExceptionAuthorizationUpdateInput;
    }
  ) => ExceptionAuthorizationPromise;
  deleteExceptionAuthorization: (
    where: ExceptionAuthorizationWhereUniqueInput
  ) => ExceptionAuthorizationPromise;
  deleteManyExceptionAuthorizations: (
    where?: ExceptionAuthorizationWhereInput
  ) => BatchPayloadPromise;
  createExceptionSlot: (data: ExceptionSlotCreateInput) => ExceptionSlotPromise;
  updateExceptionSlot: (
    args: {
      data: ExceptionSlotUpdateInput;
      where: ExceptionSlotWhereUniqueInput;
    }
  ) => ExceptionSlotPromise;
  updateManyExceptionSlots: (
    args: {
      data: ExceptionSlotUpdateManyMutationInput;
      where?: ExceptionSlotWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertExceptionSlot: (
    args: {
      where: ExceptionSlotWhereUniqueInput;
      create: ExceptionSlotCreateInput;
      update: ExceptionSlotUpdateInput;
    }
  ) => ExceptionSlotPromise;
  deleteExceptionSlot: (
    where: ExceptionSlotWhereUniqueInput
  ) => ExceptionSlotPromise;
  deleteManyExceptionSlots: (
    where?: ExceptionSlotWhereInput
  ) => BatchPayloadPromise;
  createFieldOptionLabel: (
    data: FieldOptionLabelCreateInput
  ) => FieldOptionLabelPromise;
  updateFieldOptionLabel: (
    args: {
      data: FieldOptionLabelUpdateInput;
      where: FieldOptionLabelWhereUniqueInput;
    }
  ) => FieldOptionLabelPromise;
  updateManyFieldOptionLabels: (
    args: {
      data: FieldOptionLabelUpdateManyMutationInput;
      where?: FieldOptionLabelWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertFieldOptionLabel: (
    args: {
      where: FieldOptionLabelWhereUniqueInput;
      create: FieldOptionLabelCreateInput;
      update: FieldOptionLabelUpdateInput;
    }
  ) => FieldOptionLabelPromise;
  deleteFieldOptionLabel: (
    where: FieldOptionLabelWhereUniqueInput
  ) => FieldOptionLabelPromise;
  deleteManyFieldOptionLabels: (
    where?: FieldOptionLabelWhereInput
  ) => BatchPayloadPromise;
  createHoliday: (data: HolidayCreateInput) => HolidayPromise;
  updateHoliday: (
    args: { data: HolidayUpdateInput; where: HolidayWhereUniqueInput }
  ) => HolidayPromise;
  updateManyHolidays: (
    args: { data: HolidayUpdateManyMutationInput; where?: HolidayWhereInput }
  ) => BatchPayloadPromise;
  upsertHoliday: (
    args: {
      where: HolidayWhereUniqueInput;
      create: HolidayCreateInput;
      update: HolidayUpdateInput;
    }
  ) => HolidayPromise;
  deleteHoliday: (where: HolidayWhereUniqueInput) => HolidayPromise;
  deleteManyHolidays: (where?: HolidayWhereInput) => BatchPayloadPromise;
  createSchedule: (data: ScheduleCreateInput) => SchedulePromise;
  updateSchedule: (
    args: { data: ScheduleUpdateInput; where: ScheduleWhereUniqueInput }
  ) => SchedulePromise;
  updateManySchedules: (
    args: { data: ScheduleUpdateManyMutationInput; where?: ScheduleWhereInput }
  ) => BatchPayloadPromise;
  upsertSchedule: (
    args: {
      where: ScheduleWhereUniqueInput;
      create: ScheduleCreateInput;
      update: ScheduleUpdateInput;
    }
  ) => SchedulePromise;
  deleteSchedule: (where: ScheduleWhereUniqueInput) => SchedulePromise;
  deleteManySchedules: (where?: ScheduleWhereInput) => BatchPayloadPromise;
  createScheduleCategoryConfig: (
    data: ScheduleCategoryConfigCreateInput
  ) => ScheduleCategoryConfigPromise;
  updateScheduleCategoryConfig: (
    args: {
      data: ScheduleCategoryConfigUpdateInput;
      where: ScheduleCategoryConfigWhereUniqueInput;
    }
  ) => ScheduleCategoryConfigPromise;
  updateManyScheduleCategoryConfigs: (
    args: {
      data: ScheduleCategoryConfigUpdateManyMutationInput;
      where?: ScheduleCategoryConfigWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleCategoryConfig: (
    args: {
      where: ScheduleCategoryConfigWhereUniqueInput;
      create: ScheduleCategoryConfigCreateInput;
      update: ScheduleCategoryConfigUpdateInput;
    }
  ) => ScheduleCategoryConfigPromise;
  deleteScheduleCategoryConfig: (
    where: ScheduleCategoryConfigWhereUniqueInput
  ) => ScheduleCategoryConfigPromise;
  deleteManyScheduleCategoryConfigs: (
    where?: ScheduleCategoryConfigWhereInput
  ) => BatchPayloadPromise;
  createScheduleCredit: (
    data: ScheduleCreditCreateInput
  ) => ScheduleCreditPromise;
  updateScheduleCredit: (
    args: {
      data: ScheduleCreditUpdateInput;
      where: ScheduleCreditWhereUniqueInput;
    }
  ) => ScheduleCreditPromise;
  updateManyScheduleCredits: (
    args: {
      data: ScheduleCreditUpdateManyMutationInput;
      where?: ScheduleCreditWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleCredit: (
    args: {
      where: ScheduleCreditWhereUniqueInput;
      create: ScheduleCreditCreateInput;
      update: ScheduleCreditUpdateInput;
    }
  ) => ScheduleCreditPromise;
  deleteScheduleCredit: (
    where: ScheduleCreditWhereUniqueInput
  ) => ScheduleCreditPromise;
  deleteManyScheduleCredits: (
    where?: ScheduleCreditWhereInput
  ) => BatchPayloadPromise;
  createScheduleDebit: (data: ScheduleDebitCreateInput) => ScheduleDebitPromise;
  updateScheduleDebit: (
    args: {
      data: ScheduleDebitUpdateInput;
      where: ScheduleDebitWhereUniqueInput;
    }
  ) => ScheduleDebitPromise;
  updateManyScheduleDebits: (
    args: {
      data: ScheduleDebitUpdateManyMutationInput;
      where?: ScheduleDebitWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleDebit: (
    args: {
      where: ScheduleDebitWhereUniqueInput;
      create: ScheduleDebitCreateInput;
      update: ScheduleDebitUpdateInput;
    }
  ) => ScheduleDebitPromise;
  deleteScheduleDebit: (
    where: ScheduleDebitWhereUniqueInput
  ) => ScheduleDebitPromise;
  deleteManyScheduleDebits: (
    where?: ScheduleDebitWhereInput
  ) => BatchPayloadPromise;
  createScheduleOfflineElement: (
    data: ScheduleOfflineElementCreateInput
  ) => ScheduleOfflineElementPromise;
  updateScheduleOfflineElement: (
    args: {
      data: ScheduleOfflineElementUpdateInput;
      where: ScheduleOfflineElementWhereUniqueInput;
    }
  ) => ScheduleOfflineElementPromise;
  updateManyScheduleOfflineElements: (
    args: {
      data: ScheduleOfflineElementUpdateManyMutationInput;
      where?: ScheduleOfflineElementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleOfflineElement: (
    args: {
      where: ScheduleOfflineElementWhereUniqueInput;
      create: ScheduleOfflineElementCreateInput;
      update: ScheduleOfflineElementUpdateInput;
    }
  ) => ScheduleOfflineElementPromise;
  deleteScheduleOfflineElement: (
    where: ScheduleOfflineElementWhereUniqueInput
  ) => ScheduleOfflineElementPromise;
  deleteManyScheduleOfflineElements: (
    where?: ScheduleOfflineElementWhereInput
  ) => BatchPayloadPromise;
  createScheduleRestlineElement: (
    data: ScheduleRestlineElementCreateInput
  ) => ScheduleRestlineElementPromise;
  updateScheduleRestlineElement: (
    args: {
      data: ScheduleRestlineElementUpdateInput;
      where: ScheduleRestlineElementWhereUniqueInput;
    }
  ) => ScheduleRestlineElementPromise;
  updateManyScheduleRestlineElements: (
    args: {
      data: ScheduleRestlineElementUpdateManyMutationInput;
      where?: ScheduleRestlineElementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleRestlineElement: (
    args: {
      where: ScheduleRestlineElementWhereUniqueInput;
      create: ScheduleRestlineElementCreateInput;
      update: ScheduleRestlineElementUpdateInput;
    }
  ) => ScheduleRestlineElementPromise;
  deleteScheduleRestlineElement: (
    where: ScheduleRestlineElementWhereUniqueInput
  ) => ScheduleRestlineElementPromise;
  deleteManyScheduleRestlineElements: (
    where?: ScheduleRestlineElementWhereInput
  ) => BatchPayloadPromise;
  createScheduleTimelineElement: (
    data: ScheduleTimelineElementCreateInput
  ) => ScheduleTimelineElementPromise;
  updateScheduleTimelineElement: (
    args: {
      data: ScheduleTimelineElementUpdateInput;
      where: ScheduleTimelineElementWhereUniqueInput;
    }
  ) => ScheduleTimelineElementPromise;
  updateManyScheduleTimelineElements: (
    args: {
      data: ScheduleTimelineElementUpdateManyMutationInput;
      where?: ScheduleTimelineElementWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertScheduleTimelineElement: (
    args: {
      where: ScheduleTimelineElementWhereUniqueInput;
      create: ScheduleTimelineElementCreateInput;
      update: ScheduleTimelineElementUpdateInput;
    }
  ) => ScheduleTimelineElementPromise;
  deleteScheduleTimelineElement: (
    where: ScheduleTimelineElementWhereUniqueInput
  ) => ScheduleTimelineElementPromise;
  deleteManyScheduleTimelineElements: (
    where?: ScheduleTimelineElementWhereInput
  ) => BatchPayloadPromise;
  createShift: (data: ShiftCreateInput) => ShiftPromise;
  updateShift: (
    args: { data: ShiftUpdateInput; where: ShiftWhereUniqueInput }
  ) => ShiftPromise;
  updateManyShifts: (
    args: { data: ShiftUpdateManyMutationInput; where?: ShiftWhereInput }
  ) => BatchPayloadPromise;
  upsertShift: (
    args: {
      where: ShiftWhereUniqueInput;
      create: ShiftCreateInput;
      update: ShiftUpdateInput;
    }
  ) => ShiftPromise;
  deleteShift: (where: ShiftWhereUniqueInput) => ShiftPromise;
  deleteManyShifts: (where?: ShiftWhereInput) => BatchPayloadPromise;
  createShiftSlot: (data: ShiftSlotCreateInput) => ShiftSlotPromise;
  updateShiftSlot: (
    args: { data: ShiftSlotUpdateInput; where: ShiftSlotWhereUniqueInput }
  ) => ShiftSlotPromise;
  updateManyShiftSlots: (
    args: {
      data: ShiftSlotUpdateManyMutationInput;
      where?: ShiftSlotWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertShiftSlot: (
    args: {
      where: ShiftSlotWhereUniqueInput;
      create: ShiftSlotCreateInput;
      update: ShiftSlotUpdateInput;
    }
  ) => ShiftSlotPromise;
  deleteShiftSlot: (where: ShiftSlotWhereUniqueInput) => ShiftSlotPromise;
  deleteManyShiftSlots: (where?: ShiftSlotWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserRole: (data: UserRoleCreateInput) => UserRolePromise;
  updateUserRole: (
    args: { data: UserRoleUpdateInput; where: UserRoleWhereUniqueInput }
  ) => UserRolePromise;
  updateManyUserRoles: (
    args: { data: UserRoleUpdateManyMutationInput; where?: UserRoleWhereInput }
  ) => BatchPayloadPromise;
  upsertUserRole: (
    args: {
      where: UserRoleWhereUniqueInput;
      create: UserRoleCreateInput;
      update: UserRoleUpdateInput;
    }
  ) => UserRolePromise;
  deleteUserRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  deleteManyUserRoles: (where?: UserRoleWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attendanceCycle: (
    where?: AttendanceCycleSubscriptionWhereInput
  ) => AttendanceCycleSubscriptionPayloadSubscription;
  department: (
    where?: DepartmentSubscriptionWhereInput
  ) => DepartmentSubscriptionPayloadSubscription;
  directCredit: (
    where?: DirectCreditSubscriptionWhereInput
  ) => DirectCreditSubscriptionPayloadSubscription;
  employee: (
    where?: EmployeeSubscriptionWhereInput
  ) => EmployeeSubscriptionPayloadSubscription;
  exception: (
    where?: ExceptionSubscriptionWhereInput
  ) => ExceptionSubscriptionPayloadSubscription;
  exceptionAuthorization: (
    where?: ExceptionAuthorizationSubscriptionWhereInput
  ) => ExceptionAuthorizationSubscriptionPayloadSubscription;
  exceptionSlot: (
    where?: ExceptionSlotSubscriptionWhereInput
  ) => ExceptionSlotSubscriptionPayloadSubscription;
  fieldOptionLabel: (
    where?: FieldOptionLabelSubscriptionWhereInput
  ) => FieldOptionLabelSubscriptionPayloadSubscription;
  holiday: (
    where?: HolidaySubscriptionWhereInput
  ) => HolidaySubscriptionPayloadSubscription;
  schedule: (
    where?: ScheduleSubscriptionWhereInput
  ) => ScheduleSubscriptionPayloadSubscription;
  scheduleCategoryConfig: (
    where?: ScheduleCategoryConfigSubscriptionWhereInput
  ) => ScheduleCategoryConfigSubscriptionPayloadSubscription;
  scheduleCredit: (
    where?: ScheduleCreditSubscriptionWhereInput
  ) => ScheduleCreditSubscriptionPayloadSubscription;
  scheduleDebit: (
    where?: ScheduleDebitSubscriptionWhereInput
  ) => ScheduleDebitSubscriptionPayloadSubscription;
  scheduleOfflineElement: (
    where?: ScheduleOfflineElementSubscriptionWhereInput
  ) => ScheduleOfflineElementSubscriptionPayloadSubscription;
  scheduleRestlineElement: (
    where?: ScheduleRestlineElementSubscriptionWhereInput
  ) => ScheduleRestlineElementSubscriptionPayloadSubscription;
  scheduleTimelineElement: (
    where?: ScheduleTimelineElementSubscriptionWhereInput
  ) => ScheduleTimelineElementSubscriptionPayloadSubscription;
  shift: (
    where?: ShiftSubscriptionWhereInput
  ) => ShiftSubscriptionPayloadSubscription;
  shiftSlot: (
    where?: ShiftSlotSubscriptionWhereInput
  ) => ShiftSlotSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userRole: (
    where?: UserRoleSubscriptionWhereInput
  ) => UserRoleSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type EmployeeSexEnum = "F" | "M";

export type ScheduleOfflineCategory =
  | "SCH_DAY_OFF"
  | "SCH_DAY_VACATION"
  | "SCH_DAY_HOLIDAY"
  | "SCH_DAY_SICK"
  | "SCH_DAY_PAID"
  | "SCH_DAY_UNPAID";

export type EmployeeCajaDeSaludEnum =
  | "OPTION_1"
  | "OPTION_2"
  | "OPTION_3"
  | "OPTION_4"
  | "OPTION_5"
  | "OPTION_6"
  | "OPTION_7"
  | "OPTION_8"
  | "OPTION_9";

export type ScheduleOfflineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EmployeeAFPEnum = "OPTION_1" | "OPTION_2";

export type ScheduleCategory =
  | "SCH_TIME_WORK"
  | "SCH_TIME_EXTRA"
  | "SCH_TIME_MATERNAL"
  | "SCH_TIME_LEAVE"
  | "SCH_REST_LUNCH"
  | "SCH_DAY_OFF"
  | "SCH_DAY_VACATION"
  | "SCH_DAY_HOLIDAY"
  | "SCH_DAY_SICK"
  | "SCH_DAY_PAID"
  | "SCH_DAY_UNPAID";

export type ExceptionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC";

export type ScheduleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "isPreset_ASC"
  | "isPreset_DESC"
  | "systemScheduleIdentifier_ASC"
  | "systemScheduleIdentifier_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "baseTime_ASC"
  | "baseTime_DESC";

export type UserRoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FieldOptionLabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "field_ASC"
  | "field_DESC"
  | "value_ASC"
  | "value_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRoleEnum = "ADMIN" | "MANAGER" | "SUPERVISOR" | "HR";

export type DirectCreditOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type DepartmentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type ScheduleDebitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleRestlineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "duration_ASC"
  | "duration_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "startEventRequired_ASC"
  | "startEventRequired_DESC"
  | "endEventRequired_ASC"
  | "endEventRequired_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ExceptionSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleTimelineElementOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "startTime_ASC"
  | "startTime_DESC"
  | "endTime_ASC"
  | "endTime_DESC"
  | "startEventRequired_ASC"
  | "startEventRequired_DESC"
  | "endEventRequired_ASC"
  | "endEventRequired_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ShiftSlotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "index_ASC"
  | "index_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AttendanceCycleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SystemScheduleIdentifierEnum =
  | "SYS_SCH_DAYOFF_DAYOFF"
  | "SYS_SCH_VACATION_VACATION"
  | "SYS_SCH_VACATION_DAYOFF"
  | "SYS_SCH_DAYOFF_VACATION"
  | "SYS_SCH_HOLIDAY_HOLIDAY";

export type ExceptionAuthorizationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "granted_ASC"
  | "granted_DESC";

export type ShiftOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC";

export type ScheduleCreditOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "sourceType_ASC"
  | "sourceType_DESC"
  | "sourceDate_ASC"
  | "sourceDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleCreditSourceEnum =
  | "EXCEPTION"
  | "CONCURENT_HOLIDAY"
  | "DIRECT_CREDIT";

export type ScheduleRestlineCategory = "SCH_REST_LUNCH";

export type EmployeeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "nameFirst_ASC"
  | "nameFirst_DESC"
  | "nameMiddle_ASC"
  | "nameMiddle_DESC"
  | "namePaternal_ASC"
  | "namePaternal_DESC"
  | "nameMaternal_ASC"
  | "nameMaternal_DESC"
  | "documentType_ASC"
  | "documentType_DESC"
  | "documentNumber_ASC"
  | "documentNumber_DESC"
  | "sex_ASC"
  | "sex_DESC"
  | "dateOfBirth_ASC"
  | "dateOfBirth_DESC"
  | "nationality_ASC"
  | "nationality_DESC"
  | "jubilado_ASC"
  | "jubilado_DESC"
  | "personaConDiscapacidad_ASC"
  | "personaConDiscapacidad_DESC"
  | "tutorPersonaConDiscapacidad_ASC"
  | "tutorPersonaConDiscapacidad_DESC"
  | "cajaDeSalud_ASC"
  | "cajaDeSalud_DESC"
  | "aportaAFP_ASC"
  | "aportaAFP_DESC"
  | "AFP_ASC"
  | "AFP_DESC"
  | "cargo_ASC"
  | "cargo_DESC"
  | "zkTimePin_ASC"
  | "zkTimePin_DESC";

export type ScheduleTimelineCategory =
  | "SCH_TIME_WORK"
  | "SCH_TIME_EXTRA"
  | "SCH_TIME_MATERNAL"
  | "SCH_TIME_LEAVE";

export type EmployeeDocumentTypeEnum = "CI" | "PASSAPORTE";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "username_ASC"
  | "username_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC";

export type HolidayOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ScheduleCategoryConfigOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "category_ASC"
  | "category_DESC"
  | "color_ASC"
  | "color_DESC"
  | "label_ASC"
  | "label_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface EmployeeUpdateManyWithoutDepartmentInput {
  create?:
    | EmployeeCreateWithoutDepartmentInput[]
    | EmployeeCreateWithoutDepartmentInput;
  delete?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  disconnect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
  update?:
    | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput;
  upsert?:
    | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput;
}

export type AttendanceCycleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleRestlineElementUpdateDataInput {
  category?: ScheduleRestlineCategory;
  duration?: Int;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ExceptionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  employee?: EmployeeWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  slots_every?: ExceptionSlotWhereInput;
  slots_some?: ExceptionSlotWhereInput;
  slots_none?: ExceptionSlotWhereInput;
  authorization?: ExceptionAuthorizationWhereInput;
  owner?: UserWhereInput;
  credits_every?: ScheduleCreditWhereInput;
  credits_some?: ScheduleCreditWhereInput;
  credits_none?: ScheduleCreditWhereInput;
  debits_every?: ScheduleDebitWhereInput;
  debits_some?: ScheduleDebitWhereInput;
  debits_none?: ScheduleDebitWhereInput;
  AND?: ExceptionWhereInput[] | ExceptionWhereInput;
  OR?: ExceptionWhereInput[] | ExceptionWhereInput;
  NOT?: ExceptionWhereInput[] | ExceptionWhereInput;
}

export interface ScheduleRestlineElementUpsertWithWhereUniqueNestedInput {
  where: ScheduleRestlineElementWhereUniqueInput;
  update: ScheduleRestlineElementUpdateDataInput;
  create: ScheduleRestlineElementCreateInput;
}

export interface ExceptionAuthorizationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  granted?: Boolean;
  granted_not?: Boolean;
  exception?: ExceptionWhereInput;
  owner?: UserWhereInput;
  AND?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
  OR?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
  NOT?: ExceptionAuthorizationWhereInput[] | ExceptionAuthorizationWhereInput;
}

export interface ScheduleOfflineElementUpdateOneInput {
  create?: ScheduleOfflineElementCreateInput;
  update?: ScheduleOfflineElementUpdateDataInput;
  upsert?: ScheduleOfflineElementUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScheduleOfflineElementWhereUniqueInput;
}

export interface ScheduleOfflineElementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleOfflineCategory;
  category_not?: ScheduleOfflineCategory;
  category_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  category_not_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  AND?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
  OR?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
  NOT?: ScheduleOfflineElementWhereInput[] | ScheduleOfflineElementWhereInput;
}

export interface ScheduleOfflineElementUpdateDataInput {
  category?: ScheduleOfflineCategory;
}

export interface HolidayWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  AND?: HolidayWhereInput[] | HolidayWhereInput;
  OR?: HolidayWhereInput[] | HolidayWhereInput;
  NOT?: HolidayWhereInput[] | HolidayWhereInput;
}

export interface ScheduleOfflineElementUpsertNestedInput {
  update: ScheduleOfflineElementUpdateDataInput;
  create: ScheduleOfflineElementCreateInput;
}

export interface ScheduleRestlineElementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleRestlineCategory;
  category_not?: ScheduleRestlineCategory;
  category_in?: ScheduleRestlineCategory[] | ScheduleRestlineCategory;
  category_not_in?: ScheduleRestlineCategory[] | ScheduleRestlineCategory;
  duration?: Int;
  duration_not?: Int;
  duration_in?: Int[] | Int;
  duration_not_in?: Int[] | Int;
  duration_lt?: Int;
  duration_lte?: Int;
  duration_gt?: Int;
  duration_gte?: Int;
  startTime?: Int;
  startTime_not?: Int;
  startTime_in?: Int[] | Int;
  startTime_not_in?: Int[] | Int;
  startTime_lt?: Int;
  startTime_lte?: Int;
  startTime_gt?: Int;
  startTime_gte?: Int;
  endTime?: Int;
  endTime_not?: Int;
  endTime_in?: Int[] | Int;
  endTime_not_in?: Int[] | Int;
  endTime_lt?: Int;
  endTime_lte?: Int;
  endTime_gt?: Int;
  endTime_gte?: Int;
  startEventRequired?: Boolean;
  startEventRequired_not?: Boolean;
  endEventRequired?: Boolean;
  endEventRequired_not?: Boolean;
  AND?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
  OR?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
  NOT?: ScheduleRestlineElementWhereInput[] | ScheduleRestlineElementWhereInput;
}

export interface ScheduleUpsertNestedInput {
  update: ScheduleUpdateDataInput;
  create: ScheduleCreateInput;
}

export interface ScheduleTimelineElementWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleTimelineCategory;
  category_not?: ScheduleTimelineCategory;
  category_in?: ScheduleTimelineCategory[] | ScheduleTimelineCategory;
  category_not_in?: ScheduleTimelineCategory[] | ScheduleTimelineCategory;
  startTime?: Int;
  startTime_not?: Int;
  startTime_in?: Int[] | Int;
  startTime_not_in?: Int[] | Int;
  startTime_lt?: Int;
  startTime_lte?: Int;
  startTime_gt?: Int;
  startTime_gte?: Int;
  endTime?: Int;
  endTime_not?: Int;
  endTime_in?: Int[] | Int;
  endTime_not_in?: Int[] | Int;
  endTime_lt?: Int;
  endTime_lte?: Int;
  endTime_gt?: Int;
  endTime_gte?: Int;
  startEventRequired?: Boolean;
  startEventRequired_not?: Boolean;
  endEventRequired?: Boolean;
  endEventRequired_not?: Boolean;
  AND?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
  OR?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
  NOT?: ScheduleTimelineElementWhereInput[] | ScheduleTimelineElementWhereInput;
}

export interface ShiftSlotUpsertWithWhereUniqueNestedInput {
  where: ShiftSlotWhereUniqueInput;
  update: ShiftSlotUpdateDataInput;
  create: ShiftSlotCreateInput;
}

export interface ScheduleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  isPreset?: Boolean;
  isPreset_not?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  systemScheduleIdentifier_not?: SystemScheduleIdentifierEnum;
  systemScheduleIdentifier_in?:
    | SystemScheduleIdentifierEnum[]
    | SystemScheduleIdentifierEnum;
  systemScheduleIdentifier_not_in?:
    | SystemScheduleIdentifierEnum[]
    | SystemScheduleIdentifierEnum;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  baseTime?: Int;
  baseTime_not?: Int;
  baseTime_in?: Int[] | Int;
  baseTime_not_in?: Int[] | Int;
  baseTime_lt?: Int;
  baseTime_lte?: Int;
  baseTime_gt?: Int;
  baseTime_gte?: Int;
  timeline_every?: ScheduleTimelineElementWhereInput;
  timeline_some?: ScheduleTimelineElementWhereInput;
  timeline_none?: ScheduleTimelineElementWhereInput;
  restline_every?: ScheduleRestlineElementWhereInput;
  restline_some?: ScheduleRestlineElementWhereInput;
  restline_none?: ScheduleRestlineElementWhereInput;
  offline1?: ScheduleOfflineElementWhereInput;
  offline2?: ScheduleOfflineElementWhereInput;
  AND?: ScheduleWhereInput[] | ScheduleWhereInput;
  OR?: ScheduleWhereInput[] | ScheduleWhereInput;
  NOT?: ScheduleWhereInput[] | ScheduleWhereInput;
}

export interface ExceptionCreateManyWithoutEmployeeInput {
  create?:
    | ExceptionCreateWithoutEmployeeInput[]
    | ExceptionCreateWithoutEmployeeInput;
  connect?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
}

export interface ExceptionUpsertWithoutDebitsInput {
  update: ExceptionUpdateWithoutDebitsDataInput;
  create: ExceptionCreateWithoutDebitsInput;
}

export interface ExceptionCreateWithoutEmployeeInput {
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface ExceptionSlotCreateManyInput {
  create?: ExceptionSlotCreateInput[] | ExceptionSlotCreateInput;
  connect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
}

export interface ShiftWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  employee?: EmployeeWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  slots_every?: ShiftSlotWhereInput;
  slots_some?: ShiftSlotWhereInput;
  slots_none?: ShiftSlotWhereInput;
  owner?: UserWhereInput;
  AND?: ShiftWhereInput[] | ShiftWhereInput;
  OR?: ShiftWhereInput[] | ShiftWhereInput;
  NOT?: ShiftWhereInput[] | ShiftWhereInput;
}

export interface ExceptionSlotCreateInput {
  schedule: ScheduleCreateOneInput;
  date: DateTimeInput;
}

export interface ShiftSlotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShiftSlotWhereInput;
  AND?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
  OR?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
  NOT?: ShiftSlotSubscriptionWhereInput[] | ShiftSlotSubscriptionWhereInput;
}

export interface ExceptionAuthorizationCreateOneWithoutExceptionInput {
  create?: ExceptionAuthorizationCreateWithoutExceptionInput;
  connect?: ExceptionAuthorizationWhereUniqueInput;
}

export interface UserRoleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: UserRoleWhereInput[] | UserRoleWhereInput;
  OR?: UserRoleWhereInput[] | UserRoleWhereInput;
  NOT?: UserRoleWhereInput[] | UserRoleWhereInput;
}

export interface ExceptionAuthorizationCreateWithoutExceptionInput {
  granted: Boolean;
  owner: UserCreateOneInput;
}

export interface ScheduleTimelineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleTimelineElementWhereInput;
  AND?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
  OR?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleTimelineElementSubscriptionWhereInput[]
    | ScheduleTimelineElementSubscriptionWhereInput;
}

export interface ScheduleCreditCreateManyWithoutSourceExceptionInput {
  create?:
    | ScheduleCreditCreateWithoutSourceExceptionInput[]
    | ScheduleCreditCreateWithoutSourceExceptionInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
}

export interface ScheduleRestlineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleRestlineElementWhereInput;
  AND?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
  OR?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleRestlineElementSubscriptionWhereInput[]
    | ScheduleRestlineElementSubscriptionWhereInput;
}

export interface ScheduleCreditCreateWithoutSourceExceptionInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface ScheduleOfflineElementSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleOfflineElementWhereInput;
  AND?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
  OR?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
  NOT?:
    | ScheduleOfflineElementSubscriptionWhereInput[]
    | ScheduleOfflineElementSubscriptionWhereInput;
}

export interface EmployeeCreateOneWithoutCreditsInput {
  create?: EmployeeCreateWithoutCreditsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleCreditSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleCreditWhereInput;
  AND?:
    | ScheduleCreditSubscriptionWhereInput[]
    | ScheduleCreditSubscriptionWhereInput;
  OR?:
    | ScheduleCreditSubscriptionWhereInput[]
    | ScheduleCreditSubscriptionWhereInput;
  NOT?:
    | ScheduleCreditSubscriptionWhereInput[]
    | ScheduleCreditSubscriptionWhereInput;
}

export interface EmployeeCreateWithoutCreditsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ScheduleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleWhereInput;
  AND?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  OR?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
  NOT?: ScheduleSubscriptionWhereInput[] | ScheduleSubscriptionWhereInput;
}

export interface DepartmentCreateOneWithoutSubordinatesInput {
  create?: DepartmentCreateWithoutSubordinatesInput;
  connect?: DepartmentWhereUniqueInput;
}

export interface FieldOptionLabelSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FieldOptionLabelWhereInput;
  AND?:
    | FieldOptionLabelSubscriptionWhereInput[]
    | FieldOptionLabelSubscriptionWhereInput;
  OR?:
    | FieldOptionLabelSubscriptionWhereInput[]
    | FieldOptionLabelSubscriptionWhereInput;
  NOT?:
    | FieldOptionLabelSubscriptionWhereInput[]
    | FieldOptionLabelSubscriptionWhereInput;
}

export interface DepartmentCreateWithoutSubordinatesInput {
  name: String;
  supervisors?: UserCreateManyWithoutDepartmentsInput;
}

export interface ExceptionSlotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionSlotWhereInput;
  AND?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
  OR?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
  NOT?:
    | ExceptionSlotSubscriptionWhereInput[]
    | ExceptionSlotSubscriptionWhereInput;
}

export interface UserCreateManyWithoutDepartmentsInput {
  create?:
    | UserCreateWithoutDepartmentsInput[]
    | UserCreateWithoutDepartmentsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface ExceptionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionWhereInput;
  AND?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
  OR?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
  NOT?: ExceptionSubscriptionWhereInput[] | ExceptionSubscriptionWhereInput;
}

export interface UserCreateWithoutDepartmentsInput {
  username: String;
  password: String;
  role: UserRoleEnum;
  roles?: UserRoleCreateManyInput;
}

export type DirectCreditWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitCreateManyWithoutEmployeeInput {
  create?:
    | ScheduleDebitCreateWithoutEmployeeInput[]
    | ScheduleDebitCreateWithoutEmployeeInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
}

export interface DepartmentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DepartmentWhereInput;
  AND?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  OR?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
  NOT?: DepartmentSubscriptionWhereInput[] | DepartmentSubscriptionWhereInput;
}

export interface ScheduleDebitCreateWithoutEmployeeInput {
  category: ScheduleOfflineCategory;
  exception: ExceptionCreateOneWithoutDebitsInput;
  credit: ScheduleCreditCreateOneWithoutDebitInput;
}

export interface UserRoleUpdateManyMutationInput {
  name?: String;
  description?: String;
  privileges?: UserRoleUpdateprivilegesInput;
}

export interface ExceptionCreateOneWithoutDebitsInput {
  create?: ExceptionCreateWithoutDebitsInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface UserRoleUpdateInput {
  name?: String;
  description?: String;
  privileges?: UserRoleUpdateprivilegesInput;
}

export interface ExceptionCreateWithoutDebitsInput {
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
}

export interface UserUpdateInput {
  username?: String;
  password?: String;
  departments?: DepartmentUpdateManyWithoutSupervisorsInput;
  role?: UserRoleEnum;
  roles?: UserRoleUpdateManyInput;
}

export interface EmployeeCreateOneWithoutExceptionsInput {
  create?: EmployeeCreateWithoutExceptionsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ShiftSlotUpdateManyMutationInput {
  index?: Int;
}

export interface EmployeeCreateWithoutExceptionsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ShiftUpdateManyMutationInput {
  description?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface ScheduleCreditCreateManyWithoutEmployeeInput {
  create?:
    | ScheduleCreditCreateWithoutEmployeeInput[]
    | ScheduleCreditCreateWithoutEmployeeInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
}

export interface EmployeeUpsertWithoutShiftsInput {
  update: EmployeeUpdateWithoutShiftsDataInput;
  create: EmployeeCreateWithoutShiftsInput;
}

export interface ScheduleCreditCreateWithoutEmployeeInput {
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface EmployeeUpdateOneRequiredWithoutShiftsInput {
  create?: EmployeeCreateWithoutShiftsInput;
  update?: EmployeeUpdateWithoutShiftsDataInput;
  upsert?: EmployeeUpsertWithoutShiftsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ExceptionCreateOneWithoutCreditsInput {
  create?: ExceptionCreateWithoutCreditsInput;
  connect?: ExceptionWhereUniqueInput;
}

export type ExceptionSlotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionCreateWithoutCreditsInput {
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface EmployeeCreateOneWithoutShiftsInput {
  create?: EmployeeCreateWithoutShiftsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleDebitCreateManyWithoutExceptionInput {
  create?:
    | ScheduleDebitCreateWithoutExceptionInput[]
    | ScheduleDebitCreateWithoutExceptionInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
}

export type FieldOptionLabelWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitCreateWithoutExceptionInput {
  employee: EmployeeCreateOneWithoutDebitsInput;
  category: ScheduleOfflineCategory;
  credit: ScheduleCreditCreateOneWithoutDebitInput;
}

export interface FieldOptionLabelWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  field?: String;
  field_not?: String;
  field_in?: String[] | String;
  field_not_in?: String[] | String;
  field_lt?: String;
  field_lte?: String;
  field_gt?: String;
  field_gte?: String;
  field_contains?: String;
  field_not_contains?: String;
  field_starts_with?: String;
  field_not_starts_with?: String;
  field_ends_with?: String;
  field_not_ends_with?: String;
  value?: String;
  value_not?: String;
  value_in?: String[] | String;
  value_not_in?: String[] | String;
  value_lt?: String;
  value_lte?: String;
  value_gt?: String;
  value_gte?: String;
  value_contains?: String;
  value_not_contains?: String;
  value_starts_with?: String;
  value_not_starts_with?: String;
  value_ends_with?: String;
  value_not_ends_with?: String;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  AND?: FieldOptionLabelWhereInput[] | FieldOptionLabelWhereInput;
  OR?: FieldOptionLabelWhereInput[] | FieldOptionLabelWhereInput;
  NOT?: FieldOptionLabelWhereInput[] | FieldOptionLabelWhereInput;
}

export interface EmployeeCreateOneWithoutDebitsInput {
  create?: EmployeeCreateWithoutDebitsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleRestlineElementUpdateManyMutationInput {
  category?: ScheduleRestlineCategory;
  duration?: Int;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface EmployeeCreateWithoutDebitsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
}

export interface ScheduleOfflineElementUpdateManyMutationInput {
  category?: ScheduleOfflineCategory;
}

export interface ScheduleCreditCreateOneWithoutDebitInput {
  create?: ScheduleCreditCreateWithoutDebitInput;
  connect?: ScheduleCreditWhereUniqueInput;
}

export interface ScheduleOfflineElementUpdateInput {
  category?: ScheduleOfflineCategory;
}

export interface ScheduleCreditCreateWithoutDebitInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
}

export interface ScheduleDebitUpdateInput {
  employee?: EmployeeUpdateOneRequiredWithoutDebitsInput;
  category?: ScheduleOfflineCategory;
  exception?: ExceptionUpdateOneRequiredWithoutDebitsInput;
  credit?: ScheduleCreditUpdateOneRequiredWithoutDebitInput;
}

export interface DirectCreditCreateOneWithoutCreditsInput {
  create?: DirectCreditCreateWithoutCreditsInput;
  connect?: DirectCreditWhereUniqueInput;
}

export type ScheduleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
}>;

export interface DirectCreditCreateWithoutCreditsInput {
  owner: UserCreateOneInput;
  employee: EmployeeCreateOneInput;
  description?: String;
}

export interface ScheduleCreditUpdateInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface EmployeeCreateOneInput {
  create?: EmployeeCreateInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ScheduleCategoryConfigUpdateManyMutationInput {
  category?: ScheduleCategory;
  color?: String;
  label?: String;
}

export interface EmployeeCreateInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ScheduleCategoryConfigUpdateInput {
  category?: ScheduleCategory;
  color?: String;
  label?: String;
}

export interface HolidayCreateOneInput {
  create?: HolidayCreateInput;
  connect?: HolidayWhereUniqueInput;
}

export interface ScheduleCategoryConfigWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  category?: ScheduleCategory;
  category_not?: ScheduleCategory;
  category_in?: ScheduleCategory[] | ScheduleCategory;
  category_not_in?: ScheduleCategory[] | ScheduleCategory;
  color?: String;
  color_not?: String;
  color_in?: String[] | String;
  color_not_in?: String[] | String;
  color_lt?: String;
  color_lte?: String;
  color_gt?: String;
  color_gte?: String;
  color_contains?: String;
  color_not_contains?: String;
  color_starts_with?: String;
  color_not_starts_with?: String;
  color_ends_with?: String;
  color_not_ends_with?: String;
  label?: String;
  label_not?: String;
  label_in?: String[] | String;
  label_not_in?: String[] | String;
  label_lt?: String;
  label_lte?: String;
  label_gt?: String;
  label_gte?: String;
  label_contains?: String;
  label_not_contains?: String;
  label_starts_with?: String;
  label_not_starts_with?: String;
  label_ends_with?: String;
  label_not_ends_with?: String;
  AND?: ScheduleCategoryConfigWhereInput[] | ScheduleCategoryConfigWhereInput;
  OR?: ScheduleCategoryConfigWhereInput[] | ScheduleCategoryConfigWhereInput;
  NOT?: ScheduleCategoryConfigWhereInput[] | ScheduleCategoryConfigWhereInput;
}

export interface HolidayCreateInput {
  date: DateTimeInput;
  name: String;
}

export interface ScheduleUpdateManyMutationInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime?: Int;
}

export interface ScheduleDebitCreateOneWithoutCreditInput {
  create?: ScheduleDebitCreateWithoutCreditInput;
  connect?: ScheduleDebitWhereUniqueInput;
}

export interface HolidayUpdateManyMutationInput {
  date?: DateTimeInput;
  name?: String;
}

export interface ScheduleDebitCreateWithoutCreditInput {
  employee: EmployeeCreateOneWithoutDebitsInput;
  category: ScheduleOfflineCategory;
  exception: ExceptionCreateOneWithoutDebitsInput;
}

export interface HolidayUpdateInput {
  date?: DateTimeInput;
  name?: String;
}

export interface DepartmentUpdateInput {
  name?: String;
  subordinates?: EmployeeUpdateManyWithoutDepartmentInput;
  supervisors?: UserUpdateManyWithoutDepartmentsInput;
}

export interface FieldOptionLabelUpdateInput {
  field?: String;
  value?: String;
  label?: String;
}

export interface ExceptionUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ExceptionWhereUniqueInput;
  update: ExceptionUpdateWithoutEmployeeDataInput;
  create: ExceptionCreateWithoutEmployeeInput;
}

export interface FieldOptionLabelCreateInput {
  field: String;
  value: String;
  label?: String;
}

export interface EmployeeUpdateWithWhereUniqueWithoutDepartmentInput {
  where: EmployeeWhereUniqueInput;
  data: EmployeeUpdateWithoutDepartmentDataInput;
}

export interface ExceptionSlotUpdateInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  date?: DateTimeInput;
}

export interface EmployeeUpdateWithoutDepartmentDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface ExceptionAuthorizationUpdateManyMutationInput {
  granted?: Boolean;
}

export interface ShiftUpdateManyWithoutEmployeeInput {
  create?: ShiftCreateWithoutEmployeeInput[] | ShiftCreateWithoutEmployeeInput;
  delete?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  connect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  disconnect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
  update?:
    | ShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ShiftUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ShiftUpsertWithWhereUniqueWithoutEmployeeInput;
}

export interface ExceptionUpdateWithoutAuthorizationDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ShiftUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ShiftWhereUniqueInput;
  data: ShiftUpdateWithoutEmployeeDataInput;
}

export type ScheduleRestlineElementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ShiftUpdateWithoutEmployeeDataInput {
  description?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface ExceptionCreateWithoutAuthorizationInput {
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface ShiftSlotUpdateManyInput {
  create?: ShiftSlotCreateInput[] | ShiftSlotCreateInput;
  update?:
    | ShiftSlotUpdateWithWhereUniqueNestedInput[]
    | ShiftSlotUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ShiftSlotUpsertWithWhereUniqueNestedInput[]
    | ShiftSlotUpsertWithWhereUniqueNestedInput;
  delete?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
  connect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
  disconnect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
}

export type ScheduleTimelineElementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ShiftSlotUpdateWithWhereUniqueNestedInput {
  where: ShiftSlotWhereUniqueInput;
  data: ShiftSlotUpdateDataInput;
}

export interface ExceptionUpdateManyMutationInput {
  description?: String;
}

export interface ShiftSlotUpdateDataInput {
  index?: Int;
  schedule?: ScheduleUpdateOneRequiredInput;
}

export type ShiftWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleUpdateOneRequiredInput {
  create?: ScheduleCreateInput;
  update?: ScheduleUpdateDataInput;
  upsert?: ScheduleUpsertNestedInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface EmployeeUpdateManyMutationInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
}

export interface ScheduleUpdateDataInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime?: Int;
  timeline?: ScheduleTimelineElementUpdateManyInput;
  restline?: ScheduleRestlineElementUpdateManyInput;
  offline1?: ScheduleOfflineElementUpdateOneInput;
  offline2?: ScheduleOfflineElementUpdateOneInput;
}

export type ShiftSlotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleTimelineElementUpdateManyInput {
  create?:
    | ScheduleTimelineElementCreateInput[]
    | ScheduleTimelineElementCreateInput;
  update?:
    | ScheduleTimelineElementUpdateWithWhereUniqueNestedInput[]
    | ScheduleTimelineElementUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ScheduleTimelineElementUpsertWithWhereUniqueNestedInput[]
    | ScheduleTimelineElementUpsertWithWhereUniqueNestedInput;
  delete?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
  connect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
  disconnect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
}

export interface ScheduleCreditUpsertWithWhereUniqueWithoutSourceDirectInput {
  where: ScheduleCreditWhereUniqueInput;
  update: ScheduleCreditUpdateWithoutSourceDirectDataInput;
  create: ScheduleCreditCreateWithoutSourceDirectInput;
}

export interface ScheduleTimelineElementUpdateWithWhereUniqueNestedInput {
  where: ScheduleTimelineElementWhereUniqueInput;
  data: ScheduleTimelineElementUpdateDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface ScheduleTimelineElementUpdateDataInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ScheduleCreditUpdateManyWithoutSourceDirectInput {
  create?:
    | ScheduleCreditCreateWithoutSourceDirectInput[]
    | ScheduleCreditCreateWithoutSourceDirectInput;
  delete?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  disconnect?:
    | ScheduleCreditWhereUniqueInput[]
    | ScheduleCreditWhereUniqueInput;
  update?:
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceDirectInput[]
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceDirectInput;
  upsert?:
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceDirectInput[]
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceDirectInput;
}

export interface ScheduleTimelineElementUpsertWithWhereUniqueNestedInput {
  where: ScheduleTimelineElementWhereUniqueInput;
  update: ScheduleTimelineElementUpdateDataInput;
  create: ScheduleTimelineElementCreateInput;
}

export type UserRoleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface ScheduleRestlineElementUpdateManyInput {
  create?:
    | ScheduleRestlineElementCreateInput[]
    | ScheduleRestlineElementCreateInput;
  update?:
    | ScheduleRestlineElementUpdateWithWhereUniqueNestedInput[]
    | ScheduleRestlineElementUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ScheduleRestlineElementUpsertWithWhereUniqueNestedInput[]
    | ScheduleRestlineElementUpsertWithWhereUniqueNestedInput;
  delete?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
  connect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
  disconnect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
}

export interface ScheduleCreditCreateManyWithoutSourceDirectInput {
  create?:
    | ScheduleCreditCreateWithoutSourceDirectInput[]
    | ScheduleCreditCreateWithoutSourceDirectInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
}

export interface ScheduleRestlineElementUpdateWithWhereUniqueNestedInput {
  where: ScheduleRestlineElementWhereUniqueInput;
  data: ScheduleRestlineElementUpdateDataInput;
}

export interface AttendanceCycleUpdateInput {
  name?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export interface ExceptionSlotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  schedule?: ScheduleWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
  OR?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
  NOT?: ExceptionSlotWhereInput[] | ExceptionSlotWhereInput;
}

export interface DepartmentUpdateManyMutationInput {
  name?: String;
}

export interface ScheduleCreditWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  employee?: EmployeeWhereInput;
  category?: ScheduleOfflineCategory;
  category_not?: ScheduleOfflineCategory;
  category_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  category_not_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceType_not?: ScheduleCreditSourceEnum;
  sourceType_in?: ScheduleCreditSourceEnum[] | ScheduleCreditSourceEnum;
  sourceType_not_in?: ScheduleCreditSourceEnum[] | ScheduleCreditSourceEnum;
  sourceException?: ExceptionWhereInput;
  sourceDirect?: DirectCreditWhereInput;
  sourceConcurentHoliday?: HolidayWhereInput;
  sourceDate?: DateTimeInput;
  sourceDate_not?: DateTimeInput;
  sourceDate_in?: DateTimeInput[] | DateTimeInput;
  sourceDate_not_in?: DateTimeInput[] | DateTimeInput;
  sourceDate_lt?: DateTimeInput;
  sourceDate_lte?: DateTimeInput;
  sourceDate_gt?: DateTimeInput;
  sourceDate_gte?: DateTimeInput;
  debit?: ScheduleDebitWhereInput;
  AND?: ScheduleCreditWhereInput[] | ScheduleCreditWhereInput;
  OR?: ScheduleCreditWhereInput[] | ScheduleCreditWhereInput;
  NOT?: ScheduleCreditWhereInput[] | ScheduleCreditWhereInput;
}

export interface DepartmentCreateInput {
  name: String;
  subordinates?: EmployeeCreateManyWithoutDepartmentInput;
  supervisors?: UserCreateManyWithoutDepartmentsInput;
}

export interface DirectCreditWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  owner?: UserWhereInput;
  employee?: EmployeeWhereInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  credits_every?: ScheduleCreditWhereInput;
  credits_some?: ScheduleCreditWhereInput;
  credits_none?: ScheduleCreditWhereInput;
  AND?: DirectCreditWhereInput[] | DirectCreditWhereInput;
  OR?: DirectCreditWhereInput[] | DirectCreditWhereInput;
  NOT?: DirectCreditWhereInput[] | DirectCreditWhereInput;
}

export interface EmployeeCreateWithoutDepartmentInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  shifts?: ShiftCreateManyWithoutEmployeeInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ScheduleDebitWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  employee?: EmployeeWhereInput;
  category?: ScheduleOfflineCategory;
  category_not?: ScheduleOfflineCategory;
  category_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  category_not_in?: ScheduleOfflineCategory[] | ScheduleOfflineCategory;
  exception?: ExceptionWhereInput;
  credit?: ScheduleCreditWhereInput;
  AND?: ScheduleDebitWhereInput[] | ScheduleDebitWhereInput;
  OR?: ScheduleDebitWhereInput[] | ScheduleDebitWhereInput;
  NOT?: ScheduleDebitWhereInput[] | ScheduleDebitWhereInput;
}

export interface ShiftCreateWithoutEmployeeInput {
  description?: String;
  startDate: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotCreateManyInput;
  owner: UserCreateOneInput;
}

export interface ScheduleCreditUpsertWithWhereUniqueWithoutSourceExceptionInput {
  where: ScheduleCreditWhereUniqueInput;
  update: ScheduleCreditUpdateWithoutSourceExceptionDataInput;
  create: ScheduleCreditCreateWithoutSourceExceptionInput;
}

export interface ShiftSlotCreateInput {
  index: Int;
  schedule: ScheduleCreateOneInput;
}

export interface EmployeeUpsertWithoutCreditsInput {
  update: EmployeeUpdateWithoutCreditsDataInput;
  create: EmployeeCreateWithoutCreditsInput;
}

export interface ScheduleCreateInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime: Int;
  timeline?: ScheduleTimelineElementCreateManyInput;
  restline?: ScheduleRestlineElementCreateManyInput;
  offline1?: ScheduleOfflineElementCreateOneInput;
  offline2?: ScheduleOfflineElementCreateOneInput;
}

export interface ScheduleDebitUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleDebitWhereUniqueInput;
  update: ScheduleDebitUpdateWithoutEmployeeDataInput;
  create: ScheduleDebitCreateWithoutEmployeeInput;
}

export interface ScheduleTimelineElementCreateInput {
  category: ScheduleTimelineCategory;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ShiftSlotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  index?: Int;
  index_not?: Int;
  index_in?: Int[] | Int;
  index_not_in?: Int[] | Int;
  index_lt?: Int;
  index_lte?: Int;
  index_gt?: Int;
  index_gte?: Int;
  schedule?: ScheduleWhereInput;
  AND?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
  OR?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
  NOT?: ShiftSlotWhereInput[] | ShiftSlotWhereInput;
}

export interface ScheduleRestlineElementCreateInput {
  category: ScheduleRestlineCategory;
  duration: Int;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface UserUpdateDataInput {
  username?: String;
  password?: String;
  departments?: DepartmentUpdateManyWithoutSupervisorsInput;
  role?: UserRoleEnum;
  roles?: UserRoleUpdateManyInput;
}

export interface ScheduleOfflineElementCreateInput {
  category: ScheduleOfflineCategory;
}

export interface DepartmentUpdateManyWithoutSupervisorsInput {
  create?:
    | DepartmentCreateWithoutSupervisorsInput[]
    | DepartmentCreateWithoutSupervisorsInput;
  delete?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  disconnect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
  update?:
    | DepartmentUpdateWithWhereUniqueWithoutSupervisorsInput[]
    | DepartmentUpdateWithWhereUniqueWithoutSupervisorsInput;
  upsert?:
    | DepartmentUpsertWithWhereUniqueWithoutSupervisorsInput[]
    | DepartmentUpsertWithWhereUniqueWithoutSupervisorsInput;
}

export interface UserCreateInput {
  username: String;
  password: String;
  departments?: DepartmentCreateManyWithoutSupervisorsInput;
  role: UserRoleEnum;
  roles?: UserRoleCreateManyInput;
}

export interface DepartmentUpdateWithWhereUniqueWithoutSupervisorsInput {
  where: DepartmentWhereUniqueInput;
  data: DepartmentUpdateWithoutSupervisorsDataInput;
}

export interface DepartmentCreateWithoutSupervisorsInput {
  name: String;
  subordinates?: EmployeeCreateManyWithoutDepartmentInput;
}

export interface DepartmentUpdateWithoutSupervisorsDataInput {
  name?: String;
  subordinates?: EmployeeUpdateManyWithoutDepartmentInput;
}

export interface UserRoleCreateInput {
  name: String;
  description?: String;
  privileges?: UserRoleCreateprivilegesInput;
}

export interface DepartmentUpsertWithWhereUniqueWithoutSupervisorsInput {
  where: DepartmentWhereUniqueInput;
  update: DepartmentUpdateWithoutSupervisorsDataInput;
  create: DepartmentCreateWithoutSupervisorsInput;
}

export interface UserRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserRoleWhereInput;
  AND?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
  OR?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
  NOT?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
}

export interface UserRoleUpdateManyInput {
  create?: UserRoleCreateInput[] | UserRoleCreateInput;
  update?:
    | UserRoleUpdateWithWhereUniqueNestedInput[]
    | UserRoleUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserRoleUpsertWithWhereUniqueNestedInput[]
    | UserRoleUpsertWithWhereUniqueNestedInput;
  delete?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
  connect?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
  disconnect?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
}

export interface ShiftSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ShiftWhereInput;
  AND?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
  OR?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
  NOT?: ShiftSubscriptionWhereInput[] | ShiftSubscriptionWhereInput;
}

export interface UserRoleUpdateWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput;
  data: UserRoleUpdateDataInput;
}

export interface DepartmentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  subordinates_every?: EmployeeWhereInput;
  subordinates_some?: EmployeeWhereInput;
  subordinates_none?: EmployeeWhereInput;
  supervisors_every?: UserWhereInput;
  supervisors_some?: UserWhereInput;
  supervisors_none?: UserWhereInput;
  AND?: DepartmentWhereInput[] | DepartmentWhereInput;
  OR?: DepartmentWhereInput[] | DepartmentWhereInput;
  NOT?: DepartmentWhereInput[] | DepartmentWhereInput;
}

export interface UserRoleUpdateDataInput {
  name?: String;
  description?: String;
  privileges?: UserRoleUpdateprivilegesInput;
}

export interface ScheduleDebitSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleDebitWhereInput;
  AND?:
    | ScheduleDebitSubscriptionWhereInput[]
    | ScheduleDebitSubscriptionWhereInput;
  OR?:
    | ScheduleDebitSubscriptionWhereInput[]
    | ScheduleDebitSubscriptionWhereInput;
  NOT?:
    | ScheduleDebitSubscriptionWhereInput[]
    | ScheduleDebitSubscriptionWhereInput;
}

export interface UserRoleUpdateprivilegesInput {
  set?: String[] | String;
}

export interface HolidaySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HolidayWhereInput;
  AND?: HolidaySubscriptionWhereInput[] | HolidaySubscriptionWhereInput;
  OR?: HolidaySubscriptionWhereInput[] | HolidaySubscriptionWhereInput;
  NOT?: HolidaySubscriptionWhereInput[] | HolidaySubscriptionWhereInput;
}

export interface UserRoleUpsertWithWhereUniqueNestedInput {
  where: UserRoleWhereUniqueInput;
  update: UserRoleUpdateDataInput;
  create: UserRoleCreateInput;
}

export interface ExceptionAuthorizationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ExceptionAuthorizationWhereInput;
  AND?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
  OR?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
  NOT?:
    | ExceptionAuthorizationSubscriptionWhereInput[]
    | ExceptionAuthorizationSubscriptionWhereInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface DirectCreditSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DirectCreditWhereInput;
  AND?:
    | DirectCreditSubscriptionWhereInput[]
    | DirectCreditSubscriptionWhereInput;
  OR?:
    | DirectCreditSubscriptionWhereInput[]
    | DirectCreditSubscriptionWhereInput;
  NOT?:
    | DirectCreditSubscriptionWhereInput[]
    | DirectCreditSubscriptionWhereInput;
}

export interface ShiftUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ShiftWhereUniqueInput;
  update: ShiftUpdateWithoutEmployeeDataInput;
  create: ShiftCreateWithoutEmployeeInput;
}

export type EmployeeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionUpdateManyWithoutEmployeeInput {
  create?:
    | ExceptionCreateWithoutEmployeeInput[]
    | ExceptionCreateWithoutEmployeeInput;
  delete?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
  connect?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
  disconnect?: ExceptionWhereUniqueInput[] | ExceptionWhereUniqueInput;
  update?:
    | ExceptionUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ExceptionUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ExceptionUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ExceptionUpsertWithWhereUniqueWithoutEmployeeInput;
}

export type ExceptionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ExceptionWhereUniqueInput;
  data: ExceptionUpdateWithoutEmployeeDataInput;
}

export type ExceptionAuthorizationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ExceptionUpdateWithoutEmployeeDataInput {
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ShiftUpdateInput {
  description?: String;
  employee?: EmployeeUpdateOneRequiredWithoutShiftsInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface ExceptionSlotUpdateManyInput {
  create?: ExceptionSlotCreateInput[] | ExceptionSlotCreateInput;
  update?:
    | ExceptionSlotUpdateWithWhereUniqueNestedInput[]
    | ExceptionSlotUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ExceptionSlotUpsertWithWhereUniqueNestedInput[]
    | ExceptionSlotUpsertWithWhereUniqueNestedInput;
  delete?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
  connect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
  disconnect?: ExceptionSlotWhereUniqueInput[] | ExceptionSlotWhereUniqueInput;
}

export interface ShiftCreateInput {
  description?: String;
  employee: EmployeeCreateOneWithoutShiftsInput;
  startDate: DateTimeInput;
  endDate?: DateTimeInput;
  slots?: ShiftSlotCreateManyInput;
  owner: UserCreateOneInput;
}

export interface ExceptionSlotUpdateWithWhereUniqueNestedInput {
  where: ExceptionSlotWhereUniqueInput;
  data: ExceptionSlotUpdateDataInput;
}

export interface ScheduleTimelineElementUpdateInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ExceptionSlotUpdateDataInput {
  schedule?: ScheduleUpdateOneRequiredInput;
  date?: DateTimeInput;
}

export type HolidayWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  date?: DateTimeInput;
}>;

export interface ExceptionSlotUpsertWithWhereUniqueNestedInput {
  where: ExceptionSlotWhereUniqueInput;
  update: ExceptionSlotUpdateDataInput;
  create: ExceptionSlotCreateInput;
}

export interface ScheduleDebitCreateInput {
  employee: EmployeeCreateOneWithoutDebitsInput;
  category: ScheduleOfflineCategory;
  exception: ExceptionCreateOneWithoutDebitsInput;
  credit: ScheduleCreditCreateOneWithoutDebitInput;
}

export interface ExceptionAuthorizationUpdateOneWithoutExceptionInput {
  create?: ExceptionAuthorizationCreateWithoutExceptionInput;
  update?: ExceptionAuthorizationUpdateWithoutExceptionDataInput;
  upsert?: ExceptionAuthorizationUpsertWithoutExceptionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExceptionAuthorizationWhereUniqueInput;
}

export interface ScheduleCreditCreateInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface ExceptionAuthorizationUpdateWithoutExceptionDataInput {
  granted?: Boolean;
  owner?: UserUpdateOneRequiredInput;
}

export interface AttendanceCycleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  AND?: AttendanceCycleWhereInput[] | AttendanceCycleWhereInput;
  OR?: AttendanceCycleWhereInput[] | AttendanceCycleWhereInput;
  NOT?: AttendanceCycleWhereInput[] | AttendanceCycleWhereInput;
}

export interface ExceptionAuthorizationUpsertWithoutExceptionInput {
  update: ExceptionAuthorizationUpdateWithoutExceptionDataInput;
  create: ExceptionAuthorizationCreateWithoutExceptionInput;
}

export interface ScheduleUpdateInput {
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  description?: String;
  baseTime?: Int;
  timeline?: ScheduleTimelineElementUpdateManyInput;
  restline?: ScheduleRestlineElementUpdateManyInput;
  offline1?: ScheduleOfflineElementUpdateOneInput;
  offline2?: ScheduleOfflineElementUpdateOneInput;
}

export interface ScheduleCreditUpdateManyWithoutSourceExceptionInput {
  create?:
    | ScheduleCreditCreateWithoutSourceExceptionInput[]
    | ScheduleCreditCreateWithoutSourceExceptionInput;
  delete?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  disconnect?:
    | ScheduleCreditWhereUniqueInput[]
    | ScheduleCreditWhereUniqueInput;
  update?:
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceExceptionInput[]
    | ScheduleCreditUpdateWithWhereUniqueWithoutSourceExceptionInput;
  upsert?:
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceExceptionInput[]
    | ScheduleCreditUpsertWithWhereUniqueWithoutSourceExceptionInput;
}

export interface FieldOptionLabelUpdateManyMutationInput {
  field?: String;
  value?: String;
  label?: String;
}

export interface ScheduleCreditUpdateWithWhereUniqueWithoutSourceExceptionInput {
  where: ScheduleCreditWhereUniqueInput;
  data: ScheduleCreditUpdateWithoutSourceExceptionDataInput;
}

export interface ExceptionSlotUpdateManyMutationInput {
  date?: DateTimeInput;
}

export interface ScheduleCreditUpdateWithoutSourceExceptionDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface ExceptionUpsertWithoutAuthorizationInput {
  update: ExceptionUpdateWithoutAuthorizationDataInput;
  create: ExceptionCreateWithoutAuthorizationInput;
}

export interface EmployeeUpdateOneRequiredWithoutCreditsInput {
  create?: EmployeeCreateWithoutCreditsInput;
  update?: EmployeeUpdateWithoutCreditsDataInput;
  upsert?: EmployeeUpsertWithoutCreditsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ExceptionAuthorizationUpdateInput {
  granted?: Boolean;
  exception?: ExceptionUpdateOneRequiredWithoutAuthorizationInput;
  owner?: UserUpdateOneRequiredInput;
}

export interface EmployeeUpdateWithoutCreditsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface ExceptionAuthorizationCreateInput {
  granted: Boolean;
  exception: ExceptionCreateOneWithoutAuthorizationInput;
  owner: UserCreateOneInput;
}

export interface DepartmentUpdateOneWithoutSubordinatesInput {
  create?: DepartmentCreateWithoutSubordinatesInput;
  update?: DepartmentUpdateWithoutSubordinatesDataInput;
  upsert?: DepartmentUpsertWithoutSubordinatesInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DepartmentWhereUniqueInput;
}

export interface ExceptionCreateInput {
  employee: EmployeeCreateOneWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotCreateManyInput;
  authorization?: ExceptionAuthorizationCreateOneWithoutExceptionInput;
  owner: UserCreateOneInput;
  credits?: ScheduleCreditCreateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitCreateManyWithoutExceptionInput;
}

export interface DepartmentUpdateWithoutSubordinatesDataInput {
  name?: String;
  supervisors?: UserUpdateManyWithoutDepartmentsInput;
}

export interface DirectCreditUpdateManyMutationInput {
  description?: String;
}

export interface UserUpdateManyWithoutDepartmentsInput {
  create?:
    | UserCreateWithoutDepartmentsInput[]
    | UserCreateWithoutDepartmentsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutDepartmentsInput[]
    | UserUpdateWithWhereUniqueWithoutDepartmentsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutDepartmentsInput[]
    | UserUpsertWithWhereUniqueWithoutDepartmentsInput;
}

export interface ScheduleCreditUpdateWithWhereUniqueWithoutSourceDirectInput {
  where: ScheduleCreditWhereUniqueInput;
  data: ScheduleCreditUpdateWithoutSourceDirectDataInput;
}

export interface UserUpdateWithWhereUniqueWithoutDepartmentsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutDepartmentsDataInput;
}

export interface ScheduleCreditCreateWithoutSourceDirectInput {
  employee: EmployeeCreateOneWithoutCreditsInput;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceException?: ExceptionCreateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayCreateOneInput;
  sourceDate: DateTimeInput;
  debit?: ScheduleDebitCreateOneWithoutCreditInput;
}

export interface UserUpdateWithoutDepartmentsDataInput {
  username?: String;
  password?: String;
  role?: UserRoleEnum;
  roles?: UserRoleUpdateManyInput;
}

export interface AttendanceCycleCreateInput {
  name: String;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
}

export interface UserUpsertWithWhereUniqueWithoutDepartmentsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutDepartmentsDataInput;
  create: UserCreateWithoutDepartmentsInput;
}

export interface EmployeeUpsertWithWhereUniqueWithoutDepartmentInput {
  where: EmployeeWhereUniqueInput;
  update: EmployeeUpdateWithoutDepartmentDataInput;
  create: EmployeeCreateWithoutDepartmentInput;
}

export interface DepartmentUpsertWithoutSubordinatesInput {
  update: DepartmentUpdateWithoutSubordinatesDataInput;
  create: DepartmentCreateWithoutSubordinatesInput;
}

export interface ShiftCreateManyWithoutEmployeeInput {
  create?: ShiftCreateWithoutEmployeeInput[] | ShiftCreateWithoutEmployeeInput;
  connect?: ShiftWhereUniqueInput[] | ShiftWhereUniqueInput;
}

export interface ScheduleDebitUpdateManyWithoutEmployeeInput {
  create?:
    | ScheduleDebitCreateWithoutEmployeeInput[]
    | ScheduleDebitCreateWithoutEmployeeInput;
  delete?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  disconnect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  update?:
    | ScheduleDebitUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleDebitUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ScheduleDebitUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleDebitUpsertWithWhereUniqueWithoutEmployeeInput;
}

export interface ScheduleCreateOneInput {
  create?: ScheduleCreateInput;
  connect?: ScheduleWhereUniqueInput;
}

export interface ScheduleDebitUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleDebitWhereUniqueInput;
  data: ScheduleDebitUpdateWithoutEmployeeDataInput;
}

export interface ScheduleRestlineElementCreateManyInput {
  create?:
    | ScheduleRestlineElementCreateInput[]
    | ScheduleRestlineElementCreateInput;
  connect?:
    | ScheduleRestlineElementWhereUniqueInput[]
    | ScheduleRestlineElementWhereUniqueInput;
}

export interface ScheduleDebitUpdateWithoutEmployeeDataInput {
  category?: ScheduleOfflineCategory;
  exception?: ExceptionUpdateOneRequiredWithoutDebitsInput;
  credit?: ScheduleCreditUpdateOneRequiredWithoutDebitInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface ExceptionUpdateOneRequiredWithoutDebitsInput {
  create?: ExceptionCreateWithoutDebitsInput;
  update?: ExceptionUpdateWithoutDebitsDataInput;
  upsert?: ExceptionUpsertWithoutDebitsInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface UserRoleCreateManyInput {
  create?: UserRoleCreateInput[] | UserRoleCreateInput;
  connect?: UserRoleWhereUniqueInput[] | UserRoleWhereUniqueInput;
}

export interface ExceptionUpdateWithoutDebitsDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface EmployeeUpdateOneRequiredWithoutExceptionsInput {
  create?: EmployeeCreateWithoutExceptionsInput;
  update?: EmployeeUpdateWithoutExceptionsDataInput;
  upsert?: EmployeeUpsertWithoutExceptionsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  nameFirst?: String;
  nameFirst_not?: String;
  nameFirst_in?: String[] | String;
  nameFirst_not_in?: String[] | String;
  nameFirst_lt?: String;
  nameFirst_lte?: String;
  nameFirst_gt?: String;
  nameFirst_gte?: String;
  nameFirst_contains?: String;
  nameFirst_not_contains?: String;
  nameFirst_starts_with?: String;
  nameFirst_not_starts_with?: String;
  nameFirst_ends_with?: String;
  nameFirst_not_ends_with?: String;
  nameMiddle?: String;
  nameMiddle_not?: String;
  nameMiddle_in?: String[] | String;
  nameMiddle_not_in?: String[] | String;
  nameMiddle_lt?: String;
  nameMiddle_lte?: String;
  nameMiddle_gt?: String;
  nameMiddle_gte?: String;
  nameMiddle_contains?: String;
  nameMiddle_not_contains?: String;
  nameMiddle_starts_with?: String;
  nameMiddle_not_starts_with?: String;
  nameMiddle_ends_with?: String;
  nameMiddle_not_ends_with?: String;
  namePaternal?: String;
  namePaternal_not?: String;
  namePaternal_in?: String[] | String;
  namePaternal_not_in?: String[] | String;
  namePaternal_lt?: String;
  namePaternal_lte?: String;
  namePaternal_gt?: String;
  namePaternal_gte?: String;
  namePaternal_contains?: String;
  namePaternal_not_contains?: String;
  namePaternal_starts_with?: String;
  namePaternal_not_starts_with?: String;
  namePaternal_ends_with?: String;
  namePaternal_not_ends_with?: String;
  nameMaternal?: String;
  nameMaternal_not?: String;
  nameMaternal_in?: String[] | String;
  nameMaternal_not_in?: String[] | String;
  nameMaternal_lt?: String;
  nameMaternal_lte?: String;
  nameMaternal_gt?: String;
  nameMaternal_gte?: String;
  nameMaternal_contains?: String;
  nameMaternal_not_contains?: String;
  nameMaternal_starts_with?: String;
  nameMaternal_not_starts_with?: String;
  nameMaternal_ends_with?: String;
  nameMaternal_not_ends_with?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentType_not?: EmployeeDocumentTypeEnum;
  documentType_in?: EmployeeDocumentTypeEnum[] | EmployeeDocumentTypeEnum;
  documentType_not_in?: EmployeeDocumentTypeEnum[] | EmployeeDocumentTypeEnum;
  documentNumber?: String;
  documentNumber_not?: String;
  documentNumber_in?: String[] | String;
  documentNumber_not_in?: String[] | String;
  documentNumber_lt?: String;
  documentNumber_lte?: String;
  documentNumber_gt?: String;
  documentNumber_gte?: String;
  documentNumber_contains?: String;
  documentNumber_not_contains?: String;
  documentNumber_starts_with?: String;
  documentNumber_not_starts_with?: String;
  documentNumber_ends_with?: String;
  documentNumber_not_ends_with?: String;
  sex?: EmployeeSexEnum;
  sex_not?: EmployeeSexEnum;
  sex_in?: EmployeeSexEnum[] | EmployeeSexEnum;
  sex_not_in?: EmployeeSexEnum[] | EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  dateOfBirth_not?: DateTimeInput;
  dateOfBirth_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_not_in?: DateTimeInput[] | DateTimeInput;
  dateOfBirth_lt?: DateTimeInput;
  dateOfBirth_lte?: DateTimeInput;
  dateOfBirth_gt?: DateTimeInput;
  dateOfBirth_gte?: DateTimeInput;
  nationality?: String;
  nationality_not?: String;
  nationality_in?: String[] | String;
  nationality_not_in?: String[] | String;
  nationality_lt?: String;
  nationality_lte?: String;
  nationality_gt?: String;
  nationality_gte?: String;
  nationality_contains?: String;
  nationality_not_contains?: String;
  nationality_starts_with?: String;
  nationality_not_starts_with?: String;
  nationality_ends_with?: String;
  nationality_not_ends_with?: String;
  jubilado?: Boolean;
  jubilado_not?: Boolean;
  personaConDiscapacidad?: Boolean;
  personaConDiscapacidad_not?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad_not?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  cajaDeSalud_not?: EmployeeCajaDeSaludEnum;
  cajaDeSalud_in?: EmployeeCajaDeSaludEnum[] | EmployeeCajaDeSaludEnum;
  cajaDeSalud_not_in?: EmployeeCajaDeSaludEnum[] | EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  aportaAFP_not?: Boolean;
  AFP?: EmployeeAFPEnum;
  AFP_not?: EmployeeAFPEnum;
  AFP_in?: EmployeeAFPEnum[] | EmployeeAFPEnum;
  AFP_not_in?: EmployeeAFPEnum[] | EmployeeAFPEnum;
  cargo?: String;
  cargo_not?: String;
  cargo_in?: String[] | String;
  cargo_not_in?: String[] | String;
  cargo_lt?: String;
  cargo_lte?: String;
  cargo_gt?: String;
  cargo_gte?: String;
  cargo_contains?: String;
  cargo_not_contains?: String;
  cargo_starts_with?: String;
  cargo_not_starts_with?: String;
  cargo_ends_with?: String;
  cargo_not_ends_with?: String;
  zkTimePin?: Int;
  zkTimePin_not?: Int;
  zkTimePin_in?: Int[] | Int;
  zkTimePin_not_in?: Int[] | Int;
  zkTimePin_lt?: Int;
  zkTimePin_lte?: Int;
  zkTimePin_gt?: Int;
  zkTimePin_gte?: Int;
  department?: DepartmentWhereInput;
  shifts_every?: ShiftWhereInput;
  shifts_some?: ShiftWhereInput;
  shifts_none?: ShiftWhereInput;
  exceptions_every?: ExceptionWhereInput;
  exceptions_some?: ExceptionWhereInput;
  exceptions_none?: ExceptionWhereInput;
  credits_every?: ScheduleCreditWhereInput;
  credits_some?: ScheduleCreditWhereInput;
  credits_none?: ScheduleCreditWhereInput;
  debits_every?: ScheduleDebitWhereInput;
  debits_some?: ScheduleDebitWhereInput;
  debits_none?: ScheduleDebitWhereInput;
  AND?: EmployeeWhereInput[] | EmployeeWhereInput;
  OR?: EmployeeWhereInput[] | EmployeeWhereInput;
  NOT?: EmployeeWhereInput[] | EmployeeWhereInput;
}

export interface EmployeeUpdateWithoutExceptionsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export type DepartmentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleCreditUpdateManyWithoutEmployeeInput {
  create?:
    | ScheduleCreditCreateWithoutEmployeeInput[]
    | ScheduleCreditCreateWithoutEmployeeInput;
  delete?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  connect?: ScheduleCreditWhereUniqueInput[] | ScheduleCreditWhereUniqueInput;
  disconnect?:
    | ScheduleCreditWhereUniqueInput[]
    | ScheduleCreditWhereUniqueInput;
  update?:
    | ScheduleCreditUpdateWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleCreditUpdateWithWhereUniqueWithoutEmployeeInput;
  upsert?:
    | ScheduleCreditUpsertWithWhereUniqueWithoutEmployeeInput[]
    | ScheduleCreditUpsertWithWhereUniqueWithoutEmployeeInput;
}

export interface AttendanceCycleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttendanceCycleWhereInput;
  AND?:
    | AttendanceCycleSubscriptionWhereInput[]
    | AttendanceCycleSubscriptionWhereInput;
  OR?:
    | AttendanceCycleSubscriptionWhereInput[]
    | AttendanceCycleSubscriptionWhereInput;
  NOT?:
    | AttendanceCycleSubscriptionWhereInput[]
    | AttendanceCycleSubscriptionWhereInput;
}

export interface ScheduleCreditUpdateWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleCreditWhereUniqueInput;
  data: ScheduleCreditUpdateWithoutEmployeeDataInput;
}

export interface ShiftSlotUpdateInput {
  index?: Int;
  schedule?: ScheduleUpdateOneRequiredInput;
}

export interface ScheduleCreditUpdateWithoutEmployeeDataInput {
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface EmployeeCreateWithoutShiftsInput {
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
  department?: DepartmentCreateOneWithoutSubordinatesInput;
  exceptions?: ExceptionCreateManyWithoutEmployeeInput;
  credits?: ScheduleCreditCreateManyWithoutEmployeeInput;
  debits?: ScheduleDebitCreateManyWithoutEmployeeInput;
}

export interface ExceptionUpdateOneWithoutCreditsInput {
  create?: ExceptionCreateWithoutCreditsInput;
  update?: ExceptionUpdateWithoutCreditsDataInput;
  upsert?: ExceptionUpsertWithoutCreditsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ExceptionWhereUniqueInput;
}

export interface ScheduleRestlineElementUpdateInput {
  category?: ScheduleRestlineCategory;
  duration?: Int;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ExceptionUpdateWithoutCreditsDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface ScheduleCreditUpdateManyMutationInput {
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceDate?: DateTimeInput;
}

export interface ScheduleDebitUpdateManyWithoutExceptionInput {
  create?:
    | ScheduleDebitCreateWithoutExceptionInput[]
    | ScheduleDebitCreateWithoutExceptionInput;
  delete?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  connect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  disconnect?: ScheduleDebitWhereUniqueInput[] | ScheduleDebitWhereUniqueInput;
  update?:
    | ScheduleDebitUpdateWithWhereUniqueWithoutExceptionInput[]
    | ScheduleDebitUpdateWithWhereUniqueWithoutExceptionInput;
  upsert?:
    | ScheduleDebitUpsertWithWhereUniqueWithoutExceptionInput[]
    | ScheduleDebitUpsertWithWhereUniqueWithoutExceptionInput;
}

export interface ScheduleCategoryConfigCreateInput {
  category?: ScheduleCategory;
  color?: String;
  label?: String;
}

export interface ScheduleDebitUpdateWithWhereUniqueWithoutExceptionInput {
  where: ScheduleDebitWhereUniqueInput;
  data: ScheduleDebitUpdateWithoutExceptionDataInput;
}

export type ScheduleDebitWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitUpdateWithoutExceptionDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutDebitsInput;
  category?: ScheduleOfflineCategory;
  credit?: ScheduleCreditUpdateOneRequiredWithoutDebitInput;
}

export interface ExceptionUpdateOneRequiredWithoutAuthorizationInput {
  create?: ExceptionCreateWithoutAuthorizationInput;
  update?: ExceptionUpdateWithoutAuthorizationDataInput;
  upsert?: ExceptionUpsertWithoutAuthorizationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface EmployeeUpdateOneRequiredWithoutDebitsInput {
  create?: EmployeeCreateWithoutDebitsInput;
  update?: EmployeeUpdateWithoutDebitsDataInput;
  upsert?: EmployeeUpsertWithoutDebitsInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface ExceptionUpdateInput {
  employee?: EmployeeUpdateOneRequiredWithoutExceptionsInput;
  description?: String;
  slots?: ExceptionSlotUpdateManyInput;
  authorization?: ExceptionAuthorizationUpdateOneWithoutExceptionInput;
  owner?: UserUpdateOneRequiredInput;
  credits?: ScheduleCreditUpdateManyWithoutSourceExceptionInput;
  debits?: ScheduleDebitUpdateManyWithoutExceptionInput;
}

export interface EmployeeUpdateWithoutDebitsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
}

export interface ScheduleCreditUpdateWithoutSourceDirectDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
  debit?: ScheduleDebitUpdateOneWithoutCreditInput;
}

export interface EmployeeUpsertWithoutDebitsInput {
  update: EmployeeUpdateWithoutDebitsDataInput;
  create: EmployeeCreateWithoutDebitsInput;
}

export interface DirectCreditCreateInput {
  owner: UserCreateOneInput;
  employee: EmployeeCreateOneInput;
  description?: String;
  credits?: ScheduleCreditCreateManyWithoutSourceDirectInput;
}

export interface ScheduleCreditUpdateOneRequiredWithoutDebitInput {
  create?: ScheduleCreditCreateWithoutDebitInput;
  update?: ScheduleCreditUpdateWithoutDebitDataInput;
  upsert?: ScheduleCreditUpsertWithoutDebitInput;
  connect?: ScheduleCreditWhereUniqueInput;
}

export interface EmployeeCreateManyWithoutDepartmentInput {
  create?:
    | EmployeeCreateWithoutDepartmentInput[]
    | EmployeeCreateWithoutDepartmentInput;
  connect?: EmployeeWhereUniqueInput[] | EmployeeWhereUniqueInput;
}

export interface ScheduleCreditUpdateWithoutDebitDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutCreditsInput;
  category?: ScheduleOfflineCategory;
  sourceType?: ScheduleCreditSourceEnum;
  sourceException?: ExceptionUpdateOneWithoutCreditsInput;
  sourceDirect?: DirectCreditUpdateOneWithoutCreditsInput;
  sourceConcurentHoliday?: HolidayUpdateOneInput;
  sourceDate?: DateTimeInput;
}

export interface ScheduleTimelineElementCreateManyInput {
  create?:
    | ScheduleTimelineElementCreateInput[]
    | ScheduleTimelineElementCreateInput;
  connect?:
    | ScheduleTimelineElementWhereUniqueInput[]
    | ScheduleTimelineElementWhereUniqueInput;
}

export interface DirectCreditUpdateOneWithoutCreditsInput {
  create?: DirectCreditCreateWithoutCreditsInput;
  update?: DirectCreditUpdateWithoutCreditsDataInput;
  upsert?: DirectCreditUpsertWithoutCreditsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: DirectCreditWhereUniqueInput;
}

export interface DepartmentCreateManyWithoutSupervisorsInput {
  create?:
    | DepartmentCreateWithoutSupervisorsInput[]
    | DepartmentCreateWithoutSupervisorsInput;
  connect?: DepartmentWhereUniqueInput[] | DepartmentWhereUniqueInput;
}

export interface DirectCreditUpdateWithoutCreditsDataInput {
  owner?: UserUpdateOneRequiredInput;
  employee?: EmployeeUpdateOneRequiredInput;
  description?: String;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  departments_every?: DepartmentWhereInput;
  departments_some?: DepartmentWhereInput;
  departments_none?: DepartmentWhereInput;
  role?: UserRoleEnum;
  role_not?: UserRoleEnum;
  role_in?: UserRoleEnum[] | UserRoleEnum;
  role_not_in?: UserRoleEnum[] | UserRoleEnum;
  roles_every?: UserRoleWhereInput;
  roles_some?: UserRoleWhereInput;
  roles_none?: UserRoleWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface EmployeeUpdateOneRequiredInput {
  create?: EmployeeCreateInput;
  update?: EmployeeUpdateDataInput;
  upsert?: EmployeeUpsertNestedInput;
  connect?: EmployeeWhereUniqueInput;
}

export interface EmployeeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EmployeeWhereInput;
  AND?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  OR?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
  NOT?: EmployeeSubscriptionWhereInput[] | EmployeeSubscriptionWhereInput;
}

export interface EmployeeUpdateDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface EmployeeUpdateWithoutShiftsDataInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface EmployeeUpsertNestedInput {
  update: EmployeeUpdateDataInput;
  create: EmployeeCreateInput;
}

export interface ScheduleDebitUpdateManyMutationInput {
  category?: ScheduleOfflineCategory;
}

export interface DirectCreditUpsertWithoutCreditsInput {
  update: DirectCreditUpdateWithoutCreditsDataInput;
  create: DirectCreditCreateWithoutCreditsInput;
}

export type ScheduleCreditWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface HolidayUpdateOneInput {
  create?: HolidayCreateInput;
  update?: HolidayUpdateDataInput;
  upsert?: HolidayUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: HolidayWhereUniqueInput;
}

export interface ExceptionCreateOneWithoutAuthorizationInput {
  create?: ExceptionCreateWithoutAuthorizationInput;
  connect?: ExceptionWhereUniqueInput;
}

export interface HolidayUpdateDataInput {
  date?: DateTimeInput;
  name?: String;
}

export interface DirectCreditUpdateInput {
  owner?: UserUpdateOneRequiredInput;
  employee?: EmployeeUpdateOneRequiredInput;
  description?: String;
  credits?: ScheduleCreditUpdateManyWithoutSourceDirectInput;
}

export interface HolidayUpsertNestedInput {
  update: HolidayUpdateDataInput;
  create: HolidayCreateInput;
}

export interface ShiftSlotCreateManyInput {
  create?: ShiftSlotCreateInput[] | ShiftSlotCreateInput;
  connect?: ShiftSlotWhereUniqueInput[] | ShiftSlotWhereUniqueInput;
}

export interface ScheduleCreditUpsertWithoutDebitInput {
  update: ScheduleCreditUpdateWithoutDebitDataInput;
  create: ScheduleCreditCreateWithoutDebitInput;
}

export interface UserRoleCreateprivilegesInput {
  set?: String[] | String;
}

export interface ScheduleDebitUpsertWithWhereUniqueWithoutExceptionInput {
  where: ScheduleDebitWhereUniqueInput;
  update: ScheduleDebitUpdateWithoutExceptionDataInput;
  create: ScheduleDebitCreateWithoutExceptionInput;
}

export interface UserUpdateManyMutationInput {
  username?: String;
  password?: String;
  role?: UserRoleEnum;
}

export interface ExceptionUpsertWithoutCreditsInput {
  update: ExceptionUpdateWithoutCreditsDataInput;
  create: ExceptionCreateWithoutCreditsInput;
}

export type ScheduleCategoryConfigWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleDebitUpdateOneWithoutCreditInput {
  create?: ScheduleDebitCreateWithoutCreditInput;
  update?: ScheduleDebitUpdateWithoutCreditDataInput;
  upsert?: ScheduleDebitUpsertWithoutCreditInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ScheduleDebitWhereUniqueInput;
}

export interface EmployeeUpdateInput {
  nameFirst?: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeInput;
  nationality?: String;
  jubilado?: Boolean;
  personaConDiscapacidad?: Boolean;
  tutorPersonaConDiscapacidad?: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP?: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin?: Int;
  department?: DepartmentUpdateOneWithoutSubordinatesInput;
  shifts?: ShiftUpdateManyWithoutEmployeeInput;
  exceptions?: ExceptionUpdateManyWithoutEmployeeInput;
  credits?: ScheduleCreditUpdateManyWithoutEmployeeInput;
  debits?: ScheduleDebitUpdateManyWithoutEmployeeInput;
}

export interface EmployeeUpsertWithoutExceptionsInput {
  update: EmployeeUpdateWithoutExceptionsDataInput;
  create: EmployeeCreateWithoutExceptionsInput;
}

export interface ScheduleCreditUpsertWithWhereUniqueWithoutEmployeeInput {
  where: ScheduleCreditWhereUniqueInput;
  update: ScheduleCreditUpdateWithoutEmployeeDataInput;
  create: ScheduleCreditCreateWithoutEmployeeInput;
}

export interface ScheduleDebitUpsertWithoutCreditInput {
  update: ScheduleDebitUpdateWithoutCreditDataInput;
  create: ScheduleDebitCreateWithoutCreditInput;
}

export interface ScheduleDebitUpdateWithoutCreditDataInput {
  employee?: EmployeeUpdateOneRequiredWithoutDebitsInput;
  category?: ScheduleOfflineCategory;
  exception?: ExceptionUpdateOneRequiredWithoutDebitsInput;
}

export interface AttendanceCycleUpdateManyMutationInput {
  name?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
}

export type ScheduleOfflineElementWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ScheduleTimelineElementUpdateManyMutationInput {
  category?: ScheduleTimelineCategory;
  startTime?: Int;
  endTime?: Int;
  startEventRequired?: Boolean;
  endEventRequired?: Boolean;
}

export interface ScheduleCategoryConfigSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ScheduleCategoryConfigWhereInput;
  AND?:
    | ScheduleCategoryConfigSubscriptionWhereInput[]
    | ScheduleCategoryConfigSubscriptionWhereInput;
  OR?:
    | ScheduleCategoryConfigSubscriptionWhereInput[]
    | ScheduleCategoryConfigSubscriptionWhereInput;
  NOT?:
    | ScheduleCategoryConfigSubscriptionWhereInput[]
    | ScheduleCategoryConfigSubscriptionWhereInput;
}

export interface ScheduleOfflineElementCreateOneInput {
  create?: ScheduleOfflineElementCreateInput;
  connect?: ScheduleOfflineElementWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserRolePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  privileges: String[];
}

export interface UserRolePreviousValuesPromise
  extends Promise<UserRolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  privileges: () => Promise<String[]>;
}

export interface UserRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserRolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  privileges: () => Promise<AsyncIterator<String[]>>;
}

export interface EmployeeEdge {
  cursor: String;
}

export interface EmployeeEdgePromise
  extends Promise<EmployeeEdge>,
    Fragmentable {
  node: <T = Employee>() => T;
  cursor: () => Promise<String>;
}

export interface EmployeeEdgeSubscription
  extends Promise<AsyncIterator<EmployeeEdge>>,
    Fragmentable {
  node: <T = EmployeeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Schedule {
  id: ID_Output;
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  baseTime: Int;
}

export interface SchedulePromise extends Promise<Schedule>, Fragmentable {
  id: () => Promise<ID_Output>;
  isPreset: () => Promise<Boolean>;
  systemScheduleIdentifier: () => Promise<SystemScheduleIdentifierEnum>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  baseTime: () => Promise<Int>;
  timeline: <T = FragmentableArray<ScheduleTimelineElement>>(
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  restline: <T = FragmentableArray<ScheduleRestlineElement>>(
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  offline1: <T = ScheduleOfflineElement>() => T;
  offline2: <T = ScheduleOfflineElement>() => T;
}

export interface ScheduleSubscription
  extends Promise<AsyncIterator<Schedule>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPreset: () => Promise<AsyncIterator<Boolean>>;
  systemScheduleIdentifier: () => Promise<
    AsyncIterator<SystemScheduleIdentifierEnum>
  >;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  baseTime: () => Promise<AsyncIterator<Int>>;
  timeline: <T = Promise<AsyncIterator<ScheduleTimelineElementSubscription>>>(
    args?: {
      where?: ScheduleTimelineElementWhereInput;
      orderBy?: ScheduleTimelineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  restline: <T = Promise<AsyncIterator<ScheduleRestlineElementSubscription>>>(
    args?: {
      where?: ScheduleRestlineElementWhereInput;
      orderBy?: ScheduleRestlineElementOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  offline1: <T = ScheduleOfflineElementSubscription>() => T;
  offline2: <T = ScheduleOfflineElementSubscription>() => T;
}

export interface EmployeeConnection {}

export interface EmployeeConnectionPromise
  extends Promise<EmployeeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<EmployeeEdge>>() => T;
  aggregate: <T = AggregateEmployee>() => T;
}

export interface EmployeeConnectionSubscription
  extends Promise<AsyncIterator<EmployeeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EmployeeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEmployeeSubscription>() => T;
}

export interface ShiftSlot {
  id: ID_Output;
  index: Int;
}

export interface ShiftSlotPromise extends Promise<ShiftSlot>, Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
  schedule: <T = Schedule>() => T;
}

export interface ShiftSlotSubscription
  extends Promise<AsyncIterator<ShiftSlot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
  schedule: <T = ScheduleSubscription>() => T;
}

export interface AggregateDirectCredit {
  count: Int;
}

export interface AggregateDirectCreditPromise
  extends Promise<AggregateDirectCredit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDirectCreditSubscription
  extends Promise<AsyncIterator<AggregateDirectCredit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Employee {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeOutput;
  nationality?: String;
  jubilado: Boolean;
  personaConDiscapacidad: Boolean;
  tutorPersonaConDiscapacidad: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
}

export interface EmployeePromise extends Promise<Employee>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nameFirst: () => Promise<String>;
  nameMiddle: () => Promise<String>;
  namePaternal: () => Promise<String>;
  nameMaternal: () => Promise<String>;
  documentType: () => Promise<EmployeeDocumentTypeEnum>;
  documentNumber: () => Promise<String>;
  sex: () => Promise<EmployeeSexEnum>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  nationality: () => Promise<String>;
  jubilado: () => Promise<Boolean>;
  personaConDiscapacidad: () => Promise<Boolean>;
  tutorPersonaConDiscapacidad: () => Promise<Boolean>;
  cajaDeSalud: () => Promise<EmployeeCajaDeSaludEnum>;
  aportaAFP: () => Promise<Boolean>;
  AFP: () => Promise<EmployeeAFPEnum>;
  cargo: () => Promise<String>;
  zkTimePin: () => Promise<Int>;
  department: <T = Department>() => T;
  shifts: <T = FragmentableArray<Shift>>(
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exceptions: <T = FragmentableArray<Exception>>(
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  credits: <T = FragmentableArray<ScheduleCredit>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = FragmentableArray<ScheduleDebit>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EmployeeSubscription
  extends Promise<AsyncIterator<Employee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameMiddle: () => Promise<AsyncIterator<String>>;
  namePaternal: () => Promise<AsyncIterator<String>>;
  nameMaternal: () => Promise<AsyncIterator<String>>;
  documentType: () => Promise<AsyncIterator<EmployeeDocumentTypeEnum>>;
  documentNumber: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<EmployeeSexEnum>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  nationality: () => Promise<AsyncIterator<String>>;
  jubilado: () => Promise<AsyncIterator<Boolean>>;
  personaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  tutorPersonaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  cajaDeSalud: () => Promise<AsyncIterator<EmployeeCajaDeSaludEnum>>;
  aportaAFP: () => Promise<AsyncIterator<Boolean>>;
  AFP: () => Promise<AsyncIterator<EmployeeAFPEnum>>;
  cargo: () => Promise<AsyncIterator<String>>;
  zkTimePin: () => Promise<AsyncIterator<Int>>;
  department: <T = DepartmentSubscription>() => T;
  shifts: <T = Promise<AsyncIterator<ShiftSubscription>>>(
    args?: {
      where?: ShiftWhereInput;
      orderBy?: ShiftOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  exceptions: <T = Promise<AsyncIterator<ExceptionSubscription>>>(
    args?: {
      where?: ExceptionWhereInput;
      orderBy?: ExceptionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  credits: <T = Promise<AsyncIterator<ScheduleCreditSubscription>>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = Promise<AsyncIterator<ScheduleDebitSubscription>>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DirectCreditEdge {
  cursor: String;
}

export interface DirectCreditEdgePromise
  extends Promise<DirectCreditEdge>,
    Fragmentable {
  node: <T = DirectCredit>() => T;
  cursor: () => Promise<String>;
}

export interface DirectCreditEdgeSubscription
  extends Promise<AsyncIterator<DirectCreditEdge>>,
    Fragmentable {
  node: <T = DirectCreditSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserRole {
  count: Int;
}

export interface AggregateUserRolePromise
  extends Promise<AggregateUserRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRoleSubscription
  extends Promise<AsyncIterator<AggregateUserRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttendanceCycle {
  id: ID_Output;
  name: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface AttendanceCyclePromise
  extends Promise<AttendanceCycle>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface AttendanceCycleSubscription
  extends Promise<AsyncIterator<AttendanceCycle>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserRoleConnection {}

export interface UserRoleConnectionPromise
  extends Promise<UserRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserRoleEdge>>() => T;
  aggregate: <T = AggregateUserRole>() => T;
}

export interface UserRoleConnectionSubscription
  extends Promise<AsyncIterator<UserRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserRoleSubscription>() => T;
}

export interface AttendanceCycleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface AttendanceCycleSubscriptionPayloadPromise
  extends Promise<AttendanceCycleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttendanceCycle>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttendanceCyclePreviousValues>() => T;
}

export interface AttendanceCycleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttendanceCycleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttendanceCycleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttendanceCyclePreviousValuesSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttendanceCyclePreviousValues {
  id: ID_Output;
  name: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
}

export interface AttendanceCyclePreviousValuesPromise
  extends Promise<AttendanceCyclePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface AttendanceCyclePreviousValuesSubscription
  extends Promise<AsyncIterator<AttendanceCyclePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateShiftSlot {
  count: Int;
}

export interface AggregateShiftSlotPromise
  extends Promise<AggregateShiftSlot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShiftSlotSubscription
  extends Promise<AsyncIterator<AggregateShiftSlot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DirectCreditConnection {}

export interface DirectCreditConnectionPromise
  extends Promise<DirectCreditConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DirectCreditEdge>>() => T;
  aggregate: <T = AggregateDirectCredit>() => T;
}

export interface DirectCreditConnectionSubscription
  extends Promise<AsyncIterator<DirectCreditConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DirectCreditEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDirectCreditSubscription>() => T;
}

export interface ShiftSlotConnection {}

export interface ShiftSlotConnectionPromise
  extends Promise<ShiftSlotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ShiftSlotEdge>>() => T;
  aggregate: <T = AggregateShiftSlot>() => T;
}

export interface ShiftSlotConnectionSubscription
  extends Promise<AsyncIterator<ShiftSlotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShiftSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShiftSlotSubscription>() => T;
}

export interface DepartmentSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DepartmentSubscriptionPayloadPromise
  extends Promise<DepartmentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Department>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DepartmentPreviousValues>() => T;
}

export interface DepartmentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DepartmentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DepartmentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DepartmentPreviousValuesSubscription>() => T;
}

export interface ShiftEdge {
  cursor: String;
}

export interface ShiftEdgePromise extends Promise<ShiftEdge>, Fragmentable {
  node: <T = Shift>() => T;
  cursor: () => Promise<String>;
}

export interface ShiftEdgeSubscription
  extends Promise<AsyncIterator<ShiftEdge>>,
    Fragmentable {
  node: <T = ShiftSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DepartmentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface DepartmentPreviousValuesPromise
  extends Promise<DepartmentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface DepartmentPreviousValuesSubscription
  extends Promise<AsyncIterator<DepartmentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScheduleTimelineElement {
  count: Int;
}

export interface AggregateScheduleTimelineElementPromise
  extends Promise<AggregateScheduleTimelineElement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleTimelineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleTimelineElement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttendanceCycleEdge {
  cursor: String;
}

export interface AttendanceCycleEdgePromise
  extends Promise<AttendanceCycleEdge>,
    Fragmentable {
  node: <T = AttendanceCycle>() => T;
  cursor: () => Promise<String>;
}

export interface AttendanceCycleEdgeSubscription
  extends Promise<AsyncIterator<AttendanceCycleEdge>>,
    Fragmentable {
  node: <T = AttendanceCycleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleTimelineElementConnection {}

export interface ScheduleTimelineElementConnectionPromise
  extends Promise<ScheduleTimelineElementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleTimelineElementEdge>>() => T;
  aggregate: <T = AggregateScheduleTimelineElement>() => T;
}

export interface ScheduleTimelineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleTimelineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleTimelineElementSubscription>() => T;
}

export interface DirectCreditSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DirectCreditSubscriptionPayloadPromise
  extends Promise<DirectCreditSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DirectCredit>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DirectCreditPreviousValues>() => T;
}

export interface DirectCreditSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DirectCreditSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DirectCreditSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DirectCreditPreviousValuesSubscription>() => T;
}

export interface ScheduleRestlineElementEdge {
  cursor: String;
}

export interface ScheduleRestlineElementEdgePromise
  extends Promise<ScheduleRestlineElementEdge>,
    Fragmentable {
  node: <T = ScheduleRestlineElement>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleRestlineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementEdge>>,
    Fragmentable {
  node: <T = ScheduleRestlineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DirectCreditPreviousValues {
  id: ID_Output;
  description?: String;
}

export interface DirectCreditPreviousValuesPromise
  extends Promise<DirectCreditPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  description: () => Promise<String>;
}

export interface DirectCreditPreviousValuesSubscription
  extends Promise<AsyncIterator<DirectCreditPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateScheduleOfflineElement {
  count: Int;
}

export interface AggregateScheduleOfflineElementPromise
  extends Promise<AggregateScheduleOfflineElement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleOfflineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleOfflineElement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateDepartment {
  count: Int;
}

export interface AggregateDepartmentPromise
  extends Promise<AggregateDepartment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDepartmentSubscription
  extends Promise<AsyncIterator<AggregateDepartment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleOfflineElementConnection {}

export interface ScheduleOfflineElementConnectionPromise
  extends Promise<ScheduleOfflineElementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleOfflineElementEdge>>() => T;
  aggregate: <T = AggregateScheduleOfflineElement>() => T;
}

export interface ScheduleOfflineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleOfflineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleOfflineElementSubscription>() => T;
}

export interface EmployeeSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EmployeeSubscriptionPayloadPromise
  extends Promise<EmployeeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Employee>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EmployeePreviousValues>() => T;
}

export interface EmployeeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EmployeeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EmployeeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EmployeePreviousValuesSubscription>() => T;
}

export interface AggregateScheduleDebit {
  count: Int;
}

export interface AggregateScheduleDebitPromise
  extends Promise<AggregateScheduleDebit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleDebitSubscription
  extends Promise<AsyncIterator<AggregateScheduleDebit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EmployeePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  nameFirst: String;
  nameMiddle?: String;
  namePaternal?: String;
  nameMaternal?: String;
  documentType?: EmployeeDocumentTypeEnum;
  documentNumber?: String;
  sex?: EmployeeSexEnum;
  dateOfBirth?: DateTimeOutput;
  nationality?: String;
  jubilado: Boolean;
  personaConDiscapacidad: Boolean;
  tutorPersonaConDiscapacidad: Boolean;
  cajaDeSalud?: EmployeeCajaDeSaludEnum;
  aportaAFP: Boolean;
  AFP?: EmployeeAFPEnum;
  cargo?: String;
  zkTimePin: Int;
}

export interface EmployeePreviousValuesPromise
  extends Promise<EmployeePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  nameFirst: () => Promise<String>;
  nameMiddle: () => Promise<String>;
  namePaternal: () => Promise<String>;
  nameMaternal: () => Promise<String>;
  documentType: () => Promise<EmployeeDocumentTypeEnum>;
  documentNumber: () => Promise<String>;
  sex: () => Promise<EmployeeSexEnum>;
  dateOfBirth: () => Promise<DateTimeOutput>;
  nationality: () => Promise<String>;
  jubilado: () => Promise<Boolean>;
  personaConDiscapacidad: () => Promise<Boolean>;
  tutorPersonaConDiscapacidad: () => Promise<Boolean>;
  cajaDeSalud: () => Promise<EmployeeCajaDeSaludEnum>;
  aportaAFP: () => Promise<Boolean>;
  AFP: () => Promise<EmployeeAFPEnum>;
  cargo: () => Promise<String>;
  zkTimePin: () => Promise<Int>;
}

export interface EmployeePreviousValuesSubscription
  extends Promise<AsyncIterator<EmployeePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameMiddle: () => Promise<AsyncIterator<String>>;
  namePaternal: () => Promise<AsyncIterator<String>>;
  nameMaternal: () => Promise<AsyncIterator<String>>;
  documentType: () => Promise<AsyncIterator<EmployeeDocumentTypeEnum>>;
  documentNumber: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<EmployeeSexEnum>>;
  dateOfBirth: () => Promise<AsyncIterator<DateTimeOutput>>;
  nationality: () => Promise<AsyncIterator<String>>;
  jubilado: () => Promise<AsyncIterator<Boolean>>;
  personaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  tutorPersonaConDiscapacidad: () => Promise<AsyncIterator<Boolean>>;
  cajaDeSalud: () => Promise<AsyncIterator<EmployeeCajaDeSaludEnum>>;
  aportaAFP: () => Promise<AsyncIterator<Boolean>>;
  AFP: () => Promise<AsyncIterator<EmployeeAFPEnum>>;
  cargo: () => Promise<AsyncIterator<String>>;
  zkTimePin: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleDebitConnection {}

export interface ScheduleDebitConnectionPromise
  extends Promise<ScheduleDebitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleDebitEdge>>() => T;
  aggregate: <T = AggregateScheduleDebit>() => T;
}

export interface ScheduleDebitConnectionSubscription
  extends Promise<AsyncIterator<ScheduleDebitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleDebitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleDebitSubscription>() => T;
}

export interface DepartmentEdge {
  cursor: String;
}

export interface DepartmentEdgePromise
  extends Promise<DepartmentEdge>,
    Fragmentable {
  node: <T = Department>() => T;
  cursor: () => Promise<String>;
}

export interface DepartmentEdgeSubscription
  extends Promise<AsyncIterator<DepartmentEdge>>,
    Fragmentable {
  node: <T = DepartmentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCreditEdge {
  cursor: String;
}

export interface ScheduleCreditEdgePromise
  extends Promise<ScheduleCreditEdge>,
    Fragmentable {
  node: <T = ScheduleCredit>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleCreditEdgeSubscription
  extends Promise<AsyncIterator<ScheduleCreditEdge>>,
    Fragmentable {
  node: <T = ScheduleCreditSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionSubscriptionPayloadPromise
  extends Promise<ExceptionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Exception>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionPreviousValues>() => T;
}

export interface ExceptionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionPreviousValuesSubscription>() => T;
}

export interface AggregateScheduleCategoryConfig {
  count: Int;
}

export interface AggregateScheduleCategoryConfigPromise
  extends Promise<AggregateScheduleCategoryConfig>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleCategoryConfigSubscription
  extends Promise<AsyncIterator<AggregateScheduleCategoryConfig>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionPreviousValuesPromise
  extends Promise<ExceptionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
}

export interface ExceptionPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCategoryConfigConnection {}

export interface ScheduleCategoryConfigConnectionPromise
  extends Promise<ScheduleCategoryConfigConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleCategoryConfigEdge>>() => T;
  aggregate: <T = AggregateScheduleCategoryConfig>() => T;
}

export interface ScheduleCategoryConfigConnectionSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleCategoryConfigEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleCategoryConfigSubscription>() => T;
}

export interface DepartmentConnection {}

export interface DepartmentConnectionPromise
  extends Promise<DepartmentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DepartmentEdge>>() => T;
  aggregate: <T = AggregateDepartment>() => T;
}

export interface DepartmentConnectionSubscription
  extends Promise<AsyncIterator<DepartmentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DepartmentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDepartmentSubscription>() => T;
}

export interface ScheduleCategoryConfig {
  id: ID_Output;
  category?: ScheduleCategory;
  color: String;
  label?: String;
}

export interface ScheduleCategoryConfigPromise
  extends Promise<ScheduleCategoryConfig>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleCategory>;
  color: () => Promise<String>;
  label: () => Promise<String>;
}

export interface ScheduleCategoryConfigSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfig>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleCategory>>;
  color: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionAuthorizationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionAuthorizationSubscriptionPayloadPromise
  extends Promise<ExceptionAuthorizationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionAuthorization>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionAuthorizationPreviousValues>() => T;
}

export interface ExceptionAuthorizationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionAuthorizationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionAuthorizationPreviousValuesSubscription>() => T;
}

export interface ScheduleEdge {
  cursor: String;
}

export interface ScheduleEdgePromise
  extends Promise<ScheduleEdge>,
    Fragmentable {
  node: <T = Schedule>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleEdgeSubscription
  extends Promise<AsyncIterator<ScheduleEdge>>,
    Fragmentable {
  node: <T = ScheduleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSchedule {
  count: Int;
}

export interface AggregateSchedulePromise
  extends Promise<AggregateSchedule>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleSubscription
  extends Promise<AsyncIterator<AggregateSchedule>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleRestlineElement {
  id: ID_Output;
  category: ScheduleRestlineCategory;
  duration: Int;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleRestlineElementPromise
  extends Promise<ScheduleRestlineElement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleRestlineCategory>;
  duration: () => Promise<Int>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleRestlineElementSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleRestlineCategory>>;
  duration: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export interface ScheduleConnection {}

export interface ScheduleConnectionPromise
  extends Promise<ScheduleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleEdge>>() => T;
  aggregate: <T = AggregateSchedule>() => T;
}

export interface ScheduleConnectionSubscription
  extends Promise<AsyncIterator<ScheduleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleSubscription>() => T;
}

export interface ExceptionAuthorizationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  granted: Boolean;
}

export interface ExceptionAuthorizationPreviousValuesPromise
  extends Promise<ExceptionAuthorizationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  granted: () => Promise<Boolean>;
}

export interface ExceptionAuthorizationPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  granted: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateHoliday {
  count: Int;
}

export interface AggregateHolidayPromise
  extends Promise<AggregateHoliday>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHolidaySubscription
  extends Promise<AsyncIterator<AggregateHoliday>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HolidayConnection {}

export interface HolidayConnectionPromise
  extends Promise<HolidayConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<HolidayEdge>>() => T;
  aggregate: <T = AggregateHoliday>() => T;
}

export interface HolidayConnectionSubscription
  extends Promise<AsyncIterator<HolidayConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HolidayEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHolidaySubscription>() => T;
}

export interface AggregateAttendanceCycle {
  count: Int;
}

export interface AggregateAttendanceCyclePromise
  extends Promise<AggregateAttendanceCycle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttendanceCycleSubscription
  extends Promise<AsyncIterator<AggregateAttendanceCycle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateFieldOptionLabel {
  count: Int;
}

export interface AggregateFieldOptionLabelPromise
  extends Promise<AggregateFieldOptionLabel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFieldOptionLabelSubscription
  extends Promise<AsyncIterator<AggregateFieldOptionLabel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ExceptionSlotSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ExceptionSlotSubscriptionPayloadPromise
  extends Promise<ExceptionSlotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ExceptionSlot>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ExceptionSlotPreviousValues>() => T;
}

export interface ExceptionSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ExceptionSlotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ExceptionSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ExceptionSlotPreviousValuesSubscription>() => T;
}

export interface FieldOptionLabelConnection {}

export interface FieldOptionLabelConnectionPromise
  extends Promise<FieldOptionLabelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<FieldOptionLabelEdge>>() => T;
  aggregate: <T = AggregateFieldOptionLabel>() => T;
}

export interface FieldOptionLabelConnectionSubscription
  extends Promise<AsyncIterator<FieldOptionLabelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FieldOptionLabelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFieldOptionLabelSubscription>() => T;
}

export interface ExceptionSlotPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface ExceptionSlotPreviousValuesPromise
  extends Promise<ExceptionSlotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
}

export interface ExceptionSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<ExceptionSlotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FieldOptionLabel {
  id: ID_Output;
  field: String;
  value: String;
  label?: String;
}

export interface FieldOptionLabelPromise
  extends Promise<FieldOptionLabel>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<String>;
  value: () => Promise<String>;
  label: () => Promise<String>;
}

export interface FieldOptionLabelSubscription
  extends Promise<AsyncIterator<FieldOptionLabel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleDebit {
  id: ID_Output;
  category: ScheduleOfflineCategory;
}

export interface ScheduleDebitPromise
  extends Promise<ScheduleDebit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  employee: <T = Employee>() => T;
  category: () => Promise<ScheduleOfflineCategory>;
  exception: <T = Exception>() => T;
  credit: <T = ScheduleCredit>() => T;
}

export interface ScheduleDebitSubscription
  extends Promise<AsyncIterator<ScheduleDebit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  employee: <T = EmployeeSubscription>() => T;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
  exception: <T = ExceptionSubscription>() => T;
  credit: <T = ScheduleCreditSubscription>() => T;
}

export interface ExceptionSlotEdge {
  cursor: String;
}

export interface ExceptionSlotEdgePromise
  extends Promise<ExceptionSlotEdge>,
    Fragmentable {
  node: <T = ExceptionSlot>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionSlotEdgeSubscription
  extends Promise<AsyncIterator<ExceptionSlotEdge>>,
    Fragmentable {
  node: <T = ExceptionSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FieldOptionLabelSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface FieldOptionLabelSubscriptionPayloadPromise
  extends Promise<FieldOptionLabelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FieldOptionLabel>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FieldOptionLabelPreviousValues>() => T;
}

export interface FieldOptionLabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FieldOptionLabelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FieldOptionLabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FieldOptionLabelPreviousValuesSubscription>() => T;
}

export interface AggregateExceptionAuthorization {
  count: Int;
}

export interface AggregateExceptionAuthorizationPromise
  extends Promise<AggregateExceptionAuthorization>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionAuthorizationSubscription
  extends Promise<AsyncIterator<AggregateExceptionAuthorization>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FieldOptionLabelPreviousValues {
  id: ID_Output;
  field: String;
  value: String;
  label?: String;
}

export interface FieldOptionLabelPreviousValuesPromise
  extends Promise<FieldOptionLabelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  field: () => Promise<String>;
  value: () => Promise<String>;
  label: () => Promise<String>;
}

export interface FieldOptionLabelPreviousValuesSubscription
  extends Promise<AsyncIterator<FieldOptionLabelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  field: () => Promise<AsyncIterator<String>>;
  value: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface ExceptionAuthorizationConnection {}

export interface ExceptionAuthorizationConnectionPromise
  extends Promise<ExceptionAuthorizationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExceptionAuthorizationEdge>>() => T;
  aggregate: <T = AggregateExceptionAuthorization>() => T;
}

export interface ExceptionAuthorizationConnectionSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ExceptionAuthorizationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateExceptionAuthorizationSubscription>() => T;
}

export interface Holiday {
  id: ID_Output;
  date: DateTimeOutput;
  name: String;
}

export interface HolidayPromise extends Promise<Holiday>, Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface HolidaySubscription
  extends Promise<AsyncIterator<Holiday>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AggregateException {
  count: Int;
}

export interface AggregateExceptionPromise
  extends Promise<AggregateException>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionSubscription
  extends Promise<AsyncIterator<AggregateException>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HolidaySubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HolidaySubscriptionPayloadPromise
  extends Promise<HolidaySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Holiday>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HolidayPreviousValues>() => T;
}

export interface HolidaySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HolidaySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HolidaySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HolidayPreviousValuesSubscription>() => T;
}

export interface ExceptionConnection {}

export interface ExceptionConnectionPromise
  extends Promise<ExceptionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExceptionEdge>>() => T;
  aggregate: <T = AggregateException>() => T;
}

export interface ExceptionConnectionSubscription
  extends Promise<AsyncIterator<ExceptionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExceptionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExceptionSubscription>() => T;
}

export interface HolidayPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  name: String;
}

export interface HolidayPreviousValuesPromise
  extends Promise<HolidayPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface HolidayPreviousValuesSubscription
  extends Promise<AsyncIterator<HolidayPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface Shift {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface ShiftPromise extends Promise<Shift>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  employee: <T = Employee>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  slots: <T = FragmentableArray<ShiftSlot>>(
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = User>() => T;
}

export interface ShiftSubscription
  extends Promise<AsyncIterator<Shift>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  employee: <T = EmployeeSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  slots: <T = Promise<AsyncIterator<ShiftSlotSubscription>>>(
    args?: {
      where?: ShiftSlotWhereInput;
      orderBy?: ShiftSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserSubscription>() => T;
}

export interface DirectCredit {
  id: ID_Output;
  description?: String;
}

export interface DirectCreditPromise
  extends Promise<DirectCredit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: <T = User>() => T;
  employee: <T = Employee>() => T;
  description: () => Promise<String>;
  credits: <T = FragmentableArray<ScheduleCredit>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DirectCreditSubscription
  extends Promise<AsyncIterator<DirectCredit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: <T = UserSubscription>() => T;
  employee: <T = EmployeeSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  credits: <T = Promise<AsyncIterator<ScheduleCreditSubscription>>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ScheduleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleSubscriptionPayloadPromise
  extends Promise<ScheduleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Schedule>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SchedulePreviousValues>() => T;
}

export interface ScheduleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SchedulePreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SchedulePreviousValues {
  id: ID_Output;
  isPreset?: Boolean;
  systemScheduleIdentifier?: SystemScheduleIdentifierEnum;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  baseTime: Int;
}

export interface SchedulePreviousValuesPromise
  extends Promise<SchedulePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  isPreset: () => Promise<Boolean>;
  systemScheduleIdentifier: () => Promise<SystemScheduleIdentifierEnum>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  baseTime: () => Promise<Int>;
}

export interface SchedulePreviousValuesSubscription
  extends Promise<AsyncIterator<SchedulePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  isPreset: () => Promise<AsyncIterator<Boolean>>;
  systemScheduleIdentifier: () => Promise<
    AsyncIterator<SystemScheduleIdentifierEnum>
  >;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  baseTime: () => Promise<AsyncIterator<Int>>;
}

export interface ShiftSlotEdge {
  cursor: String;
}

export interface ShiftSlotEdgePromise
  extends Promise<ShiftSlotEdge>,
    Fragmentable {
  node: <T = ShiftSlot>() => T;
  cursor: () => Promise<String>;
}

export interface ShiftSlotEdgeSubscription
  extends Promise<AsyncIterator<ShiftSlotEdge>>,
    Fragmentable {
  node: <T = ShiftSlotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCredit {
  id: ID_Output;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceDate: DateTimeOutput;
}

export interface ScheduleCreditPromise
  extends Promise<ScheduleCredit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  employee: <T = Employee>() => T;
  category: () => Promise<ScheduleOfflineCategory>;
  sourceType: () => Promise<ScheduleCreditSourceEnum>;
  sourceException: <T = Exception>() => T;
  sourceDirect: <T = DirectCredit>() => T;
  sourceConcurentHoliday: <T = Holiday>() => T;
  sourceDate: () => Promise<DateTimeOutput>;
  debit: <T = ScheduleDebit>() => T;
}

export interface ScheduleCreditSubscription
  extends Promise<AsyncIterator<ScheduleCredit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  employee: <T = EmployeeSubscription>() => T;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
  sourceType: () => Promise<AsyncIterator<ScheduleCreditSourceEnum>>;
  sourceException: <T = ExceptionSubscription>() => T;
  sourceDirect: <T = DirectCreditSubscription>() => T;
  sourceConcurentHoliday: <T = HolidaySubscription>() => T;
  sourceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  debit: <T = ScheduleDebitSubscription>() => T;
}

export interface ShiftConnection {}

export interface ShiftConnectionPromise
  extends Promise<ShiftConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ShiftEdge>>() => T;
  aggregate: <T = AggregateShift>() => T;
}

export interface ShiftConnectionSubscription
  extends Promise<AsyncIterator<ShiftConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ShiftEdgeSubscription>>>() => T;
  aggregate: <T = AggregateShiftSubscription>() => T;
}

export interface ScheduleCategoryConfigSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleCategoryConfigSubscriptionPayloadPromise
  extends Promise<ScheduleCategoryConfigSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleCategoryConfig>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleCategoryConfigPreviousValues>() => T;
}

export interface ScheduleCategoryConfigSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleCategoryConfigSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleCategoryConfigPreviousValuesSubscription>() => T;
}

export interface AggregateScheduleRestlineElement {
  count: Int;
}

export interface AggregateScheduleRestlineElementPromise
  extends Promise<AggregateScheduleRestlineElement>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleRestlineElementSubscription
  extends Promise<AsyncIterator<AggregateScheduleRestlineElement>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleCategoryConfigPreviousValues {
  id: ID_Output;
  category?: ScheduleCategory;
  color: String;
  label?: String;
}

export interface ScheduleCategoryConfigPreviousValuesPromise
  extends Promise<ScheduleCategoryConfigPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleCategory>;
  color: () => Promise<String>;
  label: () => Promise<String>;
}

export interface ScheduleCategoryConfigPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleCategory>>;
  color: () => Promise<AsyncIterator<String>>;
  label: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleOfflineElementEdge {
  cursor: String;
}

export interface ScheduleOfflineElementEdgePromise
  extends Promise<ScheduleOfflineElementEdge>,
    Fragmentable {
  node: <T = ScheduleOfflineElement>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleOfflineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementEdge>>,
    Fragmentable {
  node: <T = ScheduleOfflineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Department {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface DepartmentPromise extends Promise<Department>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  subordinates: <T = FragmentableArray<Employee>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  supervisors: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface DepartmentSubscription
  extends Promise<AsyncIterator<Department>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  subordinates: <T = Promise<AsyncIterator<EmployeeSubscription>>>(
    args?: {
      where?: EmployeeWhereInput;
      orderBy?: EmployeeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  supervisors: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ScheduleDebitEdge {
  cursor: String;
}

export interface ScheduleDebitEdgePromise
  extends Promise<ScheduleDebitEdge>,
    Fragmentable {
  node: <T = ScheduleDebit>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleDebitEdgeSubscription
  extends Promise<AsyncIterator<ScheduleDebitEdge>>,
    Fragmentable {
  node: <T = ScheduleDebitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCreditSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleCreditSubscriptionPayloadPromise
  extends Promise<ScheduleCreditSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleCredit>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleCreditPreviousValues>() => T;
}

export interface ScheduleCreditSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleCreditSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleCreditSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleCreditPreviousValuesSubscription>() => T;
}

export interface ScheduleCreditConnection {}

export interface ScheduleCreditConnectionPromise
  extends Promise<ScheduleCreditConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleCreditEdge>>() => T;
  aggregate: <T = AggregateScheduleCredit>() => T;
}

export interface ScheduleCreditConnectionSubscription
  extends Promise<AsyncIterator<ScheduleCreditConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ScheduleCreditEdgeSubscription>>>() => T;
  aggregate: <T = AggregateScheduleCreditSubscription>() => T;
}

export interface ScheduleCreditPreviousValues {
  id: ID_Output;
  category: ScheduleOfflineCategory;
  sourceType: ScheduleCreditSourceEnum;
  sourceDate: DateTimeOutput;
}

export interface ScheduleCreditPreviousValuesPromise
  extends Promise<ScheduleCreditPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
  sourceType: () => Promise<ScheduleCreditSourceEnum>;
  sourceDate: () => Promise<DateTimeOutput>;
}

export interface ScheduleCreditPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleCreditPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
  sourceType: () => Promise<AsyncIterator<ScheduleCreditSourceEnum>>;
  sourceDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ExceptionAuthorization {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  granted: Boolean;
}

export interface ExceptionAuthorizationPromise
  extends Promise<ExceptionAuthorization>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  granted: () => Promise<Boolean>;
  exception: <T = Exception>() => T;
  owner: <T = User>() => T;
}

export interface ExceptionAuthorizationSubscription
  extends Promise<AsyncIterator<ExceptionAuthorization>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  granted: () => Promise<AsyncIterator<Boolean>>;
  exception: <T = ExceptionSubscription>() => T;
  owner: <T = UserSubscription>() => T;
}

export interface AttendanceCycleConnection {}

export interface AttendanceCycleConnectionPromise
  extends Promise<AttendanceCycleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<AttendanceCycleEdge>>() => T;
  aggregate: <T = AggregateAttendanceCycle>() => T;
}

export interface AttendanceCycleConnectionSubscription
  extends Promise<AsyncIterator<AttendanceCycleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttendanceCycleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttendanceCycleSubscription>() => T;
}

export interface ScheduleDebitSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleDebitSubscriptionPayloadPromise
  extends Promise<ScheduleDebitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleDebit>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleDebitPreviousValues>() => T;
}

export interface ScheduleDebitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleDebitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleDebitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleDebitPreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleDebitPreviousValues {
  id: ID_Output;
  category: ScheduleOfflineCategory;
}

export interface ScheduleDebitPreviousValuesPromise
  extends Promise<ScheduleDebitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
}

export interface ScheduleDebitPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleDebitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
}

export interface ExceptionSlotConnection {}

export interface ExceptionSlotConnectionPromise
  extends Promise<ExceptionSlotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ExceptionSlotEdge>>() => T;
  aggregate: <T = AggregateExceptionSlot>() => T;
}

export interface ExceptionSlotConnectionSubscription
  extends Promise<AsyncIterator<ExceptionSlotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ExceptionSlotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateExceptionSlotSubscription>() => T;
}

export interface ExceptionSlot {
  id: ID_Output;
  date: DateTimeOutput;
}

export interface ExceptionSlotPromise
  extends Promise<ExceptionSlot>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  schedule: <T = Schedule>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface ExceptionSlotSubscription
  extends Promise<AsyncIterator<ExceptionSlot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  schedule: <T = ScheduleSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserRoleSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserRoleSubscriptionPayloadPromise
  extends Promise<UserRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRole>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRolePreviousValues>() => T;
}

export interface UserRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRolePreviousValuesSubscription>() => T;
}

export interface ScheduleOfflineElementSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleOfflineElementSubscriptionPayloadPromise
  extends Promise<ScheduleOfflineElementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleOfflineElement>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleOfflineElementPreviousValues>() => T;
}

export interface ScheduleOfflineElementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleOfflineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ScheduleOfflineElementPreviousValuesSubscription>() => T;
}

export interface AggregateEmployee {
  count: Int;
}

export interface AggregateEmployeePromise
  extends Promise<AggregateEmployee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEmployeeSubscription
  extends Promise<AsyncIterator<AggregateEmployee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleOfflineElementPreviousValues {
  id: ID_Output;
  category: ScheduleOfflineCategory;
}

export interface ScheduleOfflineElementPreviousValuesPromise
  extends Promise<ScheduleOfflineElementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
}

export interface ScheduleOfflineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
}

export interface UserRoleEdge {
  cursor: String;
}

export interface UserRoleEdgePromise
  extends Promise<UserRoleEdge>,
    Fragmentable {
  node: <T = UserRole>() => T;
  cursor: () => Promise<String>;
}

export interface UserRoleEdgeSubscription
  extends Promise<AsyncIterator<UserRoleEdge>>,
    Fragmentable {
  node: <T = UserRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Exception {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
}

export interface ExceptionPromise extends Promise<Exception>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  employee: <T = Employee>() => T;
  description: () => Promise<String>;
  slots: <T = FragmentableArray<ExceptionSlot>>(
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  authorization: <T = ExceptionAuthorization>() => T;
  owner: <T = User>() => T;
  credits: <T = FragmentableArray<ScheduleCredit>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = FragmentableArray<ScheduleDebit>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ExceptionSubscription
  extends Promise<AsyncIterator<Exception>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  employee: <T = EmployeeSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  slots: <T = Promise<AsyncIterator<ExceptionSlotSubscription>>>(
    args?: {
      where?: ExceptionSlotWhereInput;
      orderBy?: ExceptionSlotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  authorization: <T = ExceptionAuthorizationSubscription>() => T;
  owner: <T = UserSubscription>() => T;
  credits: <T = Promise<AsyncIterator<ScheduleCreditSubscription>>>(
    args?: {
      where?: ScheduleCreditWhereInput;
      orderBy?: ScheduleCreditOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  debits: <T = Promise<AsyncIterator<ScheduleDebitSubscription>>>(
    args?: {
      where?: ScheduleDebitWhereInput;
      orderBy?: ScheduleDebitOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateShift {
  count: Int;
}

export interface AggregateShiftPromise
  extends Promise<AggregateShift>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateShiftSubscription
  extends Promise<AsyncIterator<AggregateShift>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleRestlineElementSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleRestlineElementSubscriptionPayloadPromise
  extends Promise<ScheduleRestlineElementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleRestlineElement>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleRestlineElementPreviousValues>() => T;
}

export interface ScheduleRestlineElementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleRestlineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ScheduleRestlineElementPreviousValuesSubscription
  >() => T;
}

export interface ScheduleRestlineElementConnection {}

export interface ScheduleRestlineElementConnectionPromise
  extends Promise<ScheduleRestlineElementConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<ScheduleRestlineElementEdge>>() => T;
  aggregate: <T = AggregateScheduleRestlineElement>() => T;
}

export interface ScheduleRestlineElementConnectionSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ScheduleRestlineElementEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateScheduleRestlineElementSubscription>() => T;
}

export interface ScheduleRestlineElementPreviousValues {
  id: ID_Output;
  category: ScheduleRestlineCategory;
  duration: Int;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleRestlineElementPreviousValuesPromise
  extends Promise<ScheduleRestlineElementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleRestlineCategory>;
  duration: () => Promise<Int>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleRestlineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleRestlineElementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleRestlineCategory>>;
  duration: () => Promise<AsyncIterator<Int>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateScheduleCredit {
  count: Int;
}

export interface AggregateScheduleCreditPromise
  extends Promise<AggregateScheduleCredit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateScheduleCreditSubscription
  extends Promise<AsyncIterator<AggregateScheduleCredit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRole {
  id: ID_Output;
  name: String;
  description?: String;
  privileges: String[];
}

export interface UserRolePromise extends Promise<UserRole>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  privileges: () => Promise<String[]>;
}

export interface UserRoleSubscription
  extends Promise<AsyncIterator<UserRole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  privileges: () => Promise<AsyncIterator<String[]>>;
}

export interface HolidayEdge {
  cursor: String;
}

export interface HolidayEdgePromise extends Promise<HolidayEdge>, Fragmentable {
  node: <T = Holiday>() => T;
  cursor: () => Promise<String>;
}

export interface HolidayEdgeSubscription
  extends Promise<AsyncIterator<HolidayEdge>>,
    Fragmentable {
  node: <T = HolidaySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleTimelineElementSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ScheduleTimelineElementSubscriptionPayloadPromise
  extends Promise<ScheduleTimelineElementSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ScheduleTimelineElement>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ScheduleTimelineElementPreviousValues>() => T;
}

export interface ScheduleTimelineElementSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ScheduleTimelineElementSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ScheduleTimelineElementPreviousValuesSubscription
  >() => T;
}

export interface AggregateExceptionSlot {
  count: Int;
}

export interface AggregateExceptionSlotPromise
  extends Promise<AggregateExceptionSlot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateExceptionSlotSubscription
  extends Promise<AsyncIterator<AggregateExceptionSlot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ScheduleTimelineElementPreviousValues {
  id: ID_Output;
  category: ScheduleTimelineCategory;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleTimelineElementPreviousValuesPromise
  extends Promise<ScheduleTimelineElementPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleTimelineCategory>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleTimelineElementPreviousValuesSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleTimelineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export interface ExceptionEdge {
  cursor: String;
}

export interface ExceptionEdgePromise
  extends Promise<ExceptionEdge>,
    Fragmentable {
  node: <T = Exception>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionEdgeSubscription
  extends Promise<AsyncIterator<ExceptionEdge>>,
    Fragmentable {
  node: <T = ExceptionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
  role: UserRoleEnum;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  departments: <T = FragmentableArray<Department>>(
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  role: () => Promise<UserRoleEnum>;
  roles: <T = FragmentableArray<UserRole>>(
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  departments: <T = Promise<AsyncIterator<DepartmentSubscription>>>(
    args?: {
      where?: DepartmentWhereInput;
      orderBy?: DepartmentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  role: () => Promise<AsyncIterator<UserRoleEnum>>;
  roles: <T = Promise<AsyncIterator<UserRoleSubscription>>>(
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ShiftSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ShiftSubscriptionPayloadPromise
  extends Promise<ShiftSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Shift>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShiftPreviousValues>() => T;
}

export interface ShiftSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShiftSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShiftSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShiftPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  username: String;
  password: String;
  role: UserRoleEnum;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  username: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<UserRoleEnum>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  username: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRoleEnum>>;
}

export interface FieldOptionLabelEdge {
  cursor: String;
}

export interface FieldOptionLabelEdgePromise
  extends Promise<FieldOptionLabelEdge>,
    Fragmentable {
  node: <T = FieldOptionLabel>() => T;
  cursor: () => Promise<String>;
}

export interface FieldOptionLabelEdgeSubscription
  extends Promise<AsyncIterator<FieldOptionLabelEdge>>,
    Fragmentable {
  node: <T = FieldOptionLabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ShiftSlotPreviousValues {
  id: ID_Output;
  index: Int;
}

export interface ShiftSlotPreviousValuesPromise
  extends Promise<ShiftSlotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  index: () => Promise<Int>;
}

export interface ShiftSlotPreviousValuesSubscription
  extends Promise<AsyncIterator<ShiftSlotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  index: () => Promise<AsyncIterator<Int>>;
}

export interface ShiftSlotSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ShiftSlotSubscriptionPayloadPromise
  extends Promise<ShiftSlotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ShiftSlot>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ShiftSlotPreviousValues>() => T;
}

export interface ShiftSlotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ShiftSlotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ShiftSlotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ShiftSlotPreviousValuesSubscription>() => T;
}

export interface ScheduleOfflineElement {
  id: ID_Output;
  category: ScheduleOfflineCategory;
}

export interface ScheduleOfflineElementPromise
  extends Promise<ScheduleOfflineElement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleOfflineCategory>;
}

export interface ScheduleOfflineElementSubscription
  extends Promise<AsyncIterator<ScheduleOfflineElement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleOfflineCategory>>;
}

export interface ShiftPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  startDate: DateTimeOutput;
  endDate?: DateTimeOutput;
}

export interface ShiftPreviousValuesPromise
  extends Promise<ShiftPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
}

export interface ShiftPreviousValuesSubscription
  extends Promise<AsyncIterator<ShiftPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ExceptionAuthorizationEdge {
  cursor: String;
}

export interface ExceptionAuthorizationEdgePromise
  extends Promise<ExceptionAuthorizationEdge>,
    Fragmentable {
  node: <T = ExceptionAuthorization>() => T;
  cursor: () => Promise<String>;
}

export interface ExceptionAuthorizationEdgeSubscription
  extends Promise<AsyncIterator<ExceptionAuthorizationEdge>>,
    Fragmentable {
  node: <T = ExceptionAuthorizationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleCategoryConfigEdge {
  cursor: String;
}

export interface ScheduleCategoryConfigEdgePromise
  extends Promise<ScheduleCategoryConfigEdge>,
    Fragmentable {
  node: <T = ScheduleCategoryConfig>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleCategoryConfigEdgeSubscription
  extends Promise<AsyncIterator<ScheduleCategoryConfigEdge>>,
    Fragmentable {
  node: <T = ScheduleCategoryConfigSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleTimelineElementEdge {
  cursor: String;
}

export interface ScheduleTimelineElementEdgePromise
  extends Promise<ScheduleTimelineElementEdge>,
    Fragmentable {
  node: <T = ScheduleTimelineElement>() => T;
  cursor: () => Promise<String>;
}

export interface ScheduleTimelineElementEdgeSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElementEdge>>,
    Fragmentable {
  node: <T = ScheduleTimelineElementSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ScheduleTimelineElement {
  id: ID_Output;
  category: ScheduleTimelineCategory;
  startTime: Int;
  endTime: Int;
  startEventRequired: Boolean;
  endEventRequired: Boolean;
}

export interface ScheduleTimelineElementPromise
  extends Promise<ScheduleTimelineElement>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  category: () => Promise<ScheduleTimelineCategory>;
  startTime: () => Promise<Int>;
  endTime: () => Promise<Int>;
  startEventRequired: () => Promise<Boolean>;
  endEventRequired: () => Promise<Boolean>;
}

export interface ScheduleTimelineElementSubscription
  extends Promise<AsyncIterator<ScheduleTimelineElement>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  category: () => Promise<AsyncIterator<ScheduleTimelineCategory>>;
  startTime: () => Promise<AsyncIterator<Int>>;
  endTime: () => Promise<AsyncIterator<Int>>;
  startEventRequired: () => Promise<AsyncIterator<Boolean>>;
  endEventRequired: () => Promise<AsyncIterator<Boolean>>;
}

export type Long = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Type Defs
 */

export const prisma: Prisma;
